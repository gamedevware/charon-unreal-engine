
#pragma once
//
// The source code was generated by the Charon, GameDevWare, 2025
// License: MIT
//
//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// ReSharper disable All

#include <type_traits>

#include "GameData/UGameDataDocument.h"
#include "GameData/FLocalizedText.h"
#include "GameData/ULanguageSwitcher.h"
#include "GameData/EGameDataFormat.h"
#include "GameData/UGameDataBase.h"
#include "GameData/FGameDataLoadOptions.h"
#include "GameData/FGameDataDocumentIdConvert.h"
#include "GameData/Formatters/FGameDataReaderFactory.h"
#include "GameData/Formatters/IGameDataReader.h"

#include "Serialization/JsonReader.h"
#include "Serialization/JsonTypes.h"
#include "Serialization/Archive.h"
#include "URpgGameDataProjectSettings.h"
#include "UParameter.h"
#include "UParameterValue.h"
#include "UProvision.h"
#include "UHero.h"
#include "UItem.h"
#include "ULocation.h"
#include "UTrinket.h"
#include "UMonster.h"
#include "ULoot.h"
#include "UCombatEffect.h"
#include "UCurioCleansingOption.h"
#include "UCurio.h"
#include "UDisease.h"
#include "UQuirk.h"
#include "UCondition.h"
#include "UWeapon.h"
#include "UArmor.h"
#include "UItemWithCount.h"
#include "UStartingSet.h"
#include "EParameterId.h"
#include "EParameterValueKind.h"
#include "ELocationFlags.h"
#include "ETrinketRarity.h"
#include "EMonsterType.h"
#include "ELootType.h"
#include "EDurationUnit.h"
#include "ECurioType.h"
#include "ECurioPlacementRestictions.h"
#include "EConditionsId.h"
#include "ECurioId.h"
#include "EDiseaseId.h"
#include "EHeroId.h"
#include "EArmorId.h"
#include "EWeaponId.h"
#include "EItemId.h"
#include "ELocationId.h"
#include "EMonsterId.h"
#include "EProvisionId.h"
#include "EQuirkId.h"
#include "ETrinketId.h"
#include "UConditionsCheckFormula.h"
#include "URpgGameData.generated.h"

DECLARE_LOG_CATEGORY_EXTERN(LogURpgGameData, Log, All);

/**
  * Main class used to access game data.
  */
UCLASS(BlueprintType)
class RPGGAMEDATA_API URpgGameData : public UGameDataBase
{
	GENERATED_BODY()

public:
	inline static const FString GeneratorName = TEXT("Charon");
	inline static const FString GeneratorVersion = TEXT("2025.1.1.0");

private:
	UPROPERTY()
	TMap<FString,URpgGameDataProjectSettings*> AllProjectSettingsList;
	UPROPERTY()
	TMap<FString,URpgGameDataProjectSettings*> ProjectSettingsList;
	UPROPERTY()
	TMap<int32,UStartingSet*> AllStartingSets;
	UPROPERTY()
	TMap<int32,UStartingSet*> StartingSets;

	TSharedPtr<TArray<UGameDataDocument*>> RootDocuments;
	TSharedPtr<TArray<UGameDataDocument*>> AllDocuments;

	UPROPERTY()
	ULanguageSwitcher* LanguageSwitcher;

public:
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	int32 ChangeNumber;

	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	FString RevisionHash;

	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	FString GameDataVersion;

	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TArray<FString> SupportedLanguages;

	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	URpgGameDataProjectSettings* ProjectSettings;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<EParameterId,UParameter*> AllParameters;
	UPROPERTY(BlueprintReadOnly)
	TMap<EParameterId,UParameter*> Parameters;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<int32,UParameterValue*> AllParameterValues;
	UPROPERTY(BlueprintReadOnly)
	TMap<int32,UParameterValue*> ParameterValues;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,UProvision*> AllProvisions;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,UProvision*> Provisions;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,UHero*> AllHeros;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,UHero*> Heros;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,UItem*> AllItems;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,UItem*> Items;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,ULocation*> AllLocations;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,ULocation*> Locations;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,UTrinket*> AllTrinkets;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,UTrinket*> Trinkets;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,UMonster*> AllMonsters;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,UMonster*> Monsters;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<int32,ULoot*> AllLoots;
	UPROPERTY(BlueprintReadOnly)
	TMap<int32,ULoot*> Loots;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<int32,UCombatEffect*> AllCombatEffects;
	UPROPERTY(BlueprintReadOnly)
	TMap<int32,UCombatEffect*> CombatEffects;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<int32,UCurioCleansingOption*> AllCurioCleansingOptions;
	UPROPERTY(BlueprintReadOnly)
	TMap<int32,UCurioCleansingOption*> CurioCleansingOptions;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,UCurio*> AllCurios;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,UCurio*> Curios;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,UDisease*> AllDiseases;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,UDisease*> Diseases;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,UQuirk*> AllQuirks;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,UQuirk*> Quirks;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,UCondition*> AllConditionsList;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,UCondition*> ConditionsList;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,UWeapon*> AllWeapons;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,UWeapon*> Weapons;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,UArmor*> AllArmors;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,UArmor*> Armors;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<int32,UItemWithCount*> AllItemWithCounts;
	UPROPERTY(BlueprintReadOnly)
	TMap<int32,UItemWithCount*> ItemWithCounts;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	UStartingSet* StartingSet;

	virtual bool TryLoad(FArchive* const GameDataStream, EGameDataFormat Format) override;
	bool TryLoad(FArchive* const GameDataStream, FGameDataLoadOptions Options);

	const TArray<UGameDataDocument*>& GetAllDocuments() const;
	const TArray<UGameDataDocument*>& GetRootDocuments() const;

	virtual UGameDataDocument* FindGameDataDocumentById(const FString& SchemaNameOrId, const FString& DocumentId) override;
	virtual UClass* FindDocumentSchemaClass(const FString& SchemaNameOrId) override;
	virtual void GetDocumentIds(const FString& SchemaNameOrId, TArray<FString>& OutAllIds) override;
	virtual void GetDocumentSchemaNames(TArray<FString>& OutAllSchemaNames) override;
	virtual void SetSupportedLanguages(const TArray<FString>& LanguageIds) override;
		
	UFUNCTION(BlueprintCallable)
	void SetLanguage(
		FString LanguageId,
		FString FallbackLanguageId = TEXT("en-US"),
		ELocalizedTextFallbackOption FallbackOption = ELocalizedTextFallbackOption::OnNull)
	{
		if (LanguageSwitcher == nullptr)
		{
			return;
		}

		LanguageSwitcher->CurrentLanguageId = LanguageId;
		LanguageSwitcher->FallbackLanguageId = FallbackLanguageId;
		LanguageSwitcher->FallbackOption = FallbackOption;
	}

private:
	void Empty();
	void UpdateProjectSettings();
	void UpdateSettings();
	void ParseLanguageList(const FString& InLanguages, TArray<FString>& OutLanguageList);

	template <typename IdType, typename DocumentType>
	DocumentType* GetOne(const TMap<IdType, DocumentType*>& Documents) const;
	template <typename IdType, typename DocumentType>
	void ToMapById(TMap<IdType, DocumentType*>& DocumentsById, TArray<DocumentType*>& Documents);
	TSharedRef<IGameDataReader> CreateReader(FArchive* const GameDataStream, const FGameDataLoadOptions& Options);

	bool ReadGameData(const TSharedRef<IGameDataReader>& Reader);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		URpgGameDataProjectSettings*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UParameter*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UParameterValue*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UProvision*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UHero*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UItem*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		ULocation*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UTrinket*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UMonster*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		ULoot*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UCombatEffect*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UCurioCleansingOption*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UCurio*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UDisease*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UQuirk*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UCondition*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UWeapon*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UArmor*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UItemWithCount*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UStartingSet*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	template <typename IdType, typename DocumentType>
	bool ReadDocumentCollection
	(
		const TSharedRef<IGameDataReader>& Reader,
		TMap<IdType,DocumentType*>& Collection,
		int32 Capacity,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadLocalizedText
	(
		const TSharedRef<IGameDataReader>& Reader,
		FLocalizedText& LocalizedText,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);

	template <typename DocumentReferenceType>
	bool ReadDocumentReferenceCollection
	(
		const TSharedRef<IGameDataReader>& Reader,
		TArray<DocumentReferenceType>& Collection,
		const FString& SchemaIdOrName,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);

	bool ReadDocumentReference
	(
		const TSharedRef<IGameDataReader>& Reader,
		FGameDataDocumentReference& DocumentReference,
		const FString& SchemaIdOrName,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);

	template <typename FormulaType>
	bool ReadFormula
	(
		const TSharedRef<IGameDataReader>& Reader,
		FormulaType*& Formula,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);

	FString CombineGameDataPath(const TArray<FString>& GameDataPath);
	TSharedPtr<FJsonObject> MergeGameData(const TSharedPtr<FJsonObject>& GameDataDocument, const TSharedPtr<FJsonObject>& PatchDocument);
	TSharedPtr<FJsonValue> MergeDocumentCollection(TSharedRef<FJsonValue> OriginalCollection, TSharedRef<FJsonValue> ModifiedCollection, const FString TypeName, bool PurgeRest);
	TSharedPtr<FJsonValue> MergeDocument(TSharedRef<FJsonValue> OriginalDocument, TSharedRef<FJsonValue> ModifiedDocument, const FString& TypeName);
	typedef TOptional<TFunction<TSharedPtr<FJsonValue>(TSharedRef<FJsonValue>, TSharedRef<FJsonValue>)>> OptionalMergeValueFunc;
	void MergePropertyDocumentValue(TSharedRef<FJsonObject> MergedDocument, TSharedRef<FJsonObject> OriginalDocument, TSharedRef<FJsonObject> ModifiedDocument, const FString PropertyName, OptionalMergeValueFunc MergeFn = OptionalMergeValueFunc());
	void MergePropertyLanguagesValue(TSharedRef<FJsonObject> MergedDocument, TSharedRef<FJsonObject> OriginalDocument, TSharedRef<FJsonObject> ModifiedDocument, const FString PropertyName);
	void MergePropertyValue(TSharedRef<FJsonObject> MergedDocument, TSharedRef<FJsonObject> OriginalDocument, TSharedRef<FJsonObject> ModifiedDocument, const FString PropertyName, OptionalMergeValueFunc MergeFn = OptionalMergeValueFunc());
	TSharedRef<FJsonValue> MergeLocalizedText(TSharedRef<FJsonValue> OriginalLocalizedText, TSharedRef<FJsonValue> ModifiedLocalizedText);
	TSharedRef<TArray<FString>> MergeKeys(const TMap<FString, TSharedPtr<FJsonValue>>& Collection1, const TMap<FString, TSharedPtr<FJsonValue>>& Collection2);
public:
	void ResolveAllReferences();
	void FindAllDocuments();

	class FVisitor
	{
	public:
		virtual ~FVisitor() = default;

		/*
         * Base visit method. Called to dispatch each document.
		 */
		virtual void Visit(UGameDataDocument* Document);

		// visit methods
		virtual void Visit(URpgGameDataProjectSettings& Document);
		virtual void Visit(UParameter& Document);
		virtual void Visit(UParameterValue& Document);
		virtual void Visit(UProvision& Document);
		virtual void Visit(UHero& Document);
		virtual void Visit(UItem& Document);
		virtual void Visit(ULocation& Document);
		virtual void Visit(UTrinket& Document);
		virtual void Visit(UMonster& Document);
		virtual void Visit(ULoot& Document);
		virtual void Visit(UCombatEffect& Document);
		virtual void Visit(UCurioCleansingOption& Document);
		virtual void Visit(UCurio& Document);
		virtual void Visit(UDisease& Document);
		virtual void Visit(UQuirk& Document);
		virtual void Visit(UCondition& Document);
		virtual void Visit(UWeapon& Document);
		virtual void Visit(UArmor& Document);
		virtual void Visit(UItemWithCount& Document);
		virtual void Visit(UStartingSet& Document);
	};

	void ApplyVisitor(FVisitor& Visitor) const;

	class FFindingVisitor : public FVisitor
	{
	public:
		// collected documents
		TArray<URpgGameDataProjectSettings*> ProjectSettings = TArray<URpgGameDataProjectSettings*>();
		TArray<UParameter*> Parameter = TArray<UParameter*>();
		TArray<UParameterValue*> ParameterValue = TArray<UParameterValue*>();
		TArray<UProvision*> Provision = TArray<UProvision*>();
		TArray<UHero*> Hero = TArray<UHero*>();
		TArray<UItem*> Item = TArray<UItem*>();
		TArray<ULocation*> Location = TArray<ULocation*>();
		TArray<UTrinket*> Trinket = TArray<UTrinket*>();
		TArray<UMonster*> Monster = TArray<UMonster*>();
		TArray<ULoot*> Loot = TArray<ULoot*>();
		TArray<UCombatEffect*> CombatEffect = TArray<UCombatEffect*>();
		TArray<UCurioCleansingOption*> CurioCleansingOption = TArray<UCurioCleansingOption*>();
		TArray<UCurio*> Curio = TArray<UCurio*>();
		TArray<UDisease*> Disease = TArray<UDisease*>();
		TArray<UQuirk*> Quirk = TArray<UQuirk*>();
		TArray<UCondition*> Conditions = TArray<UCondition*>();
		TArray<UWeapon*> Weapon = TArray<UWeapon*>();
		TArray<UArmor*> Armor = TArray<UArmor*>();
		TArray<UItemWithCount*> ItemWithCount = TArray<UItemWithCount*>();
		TArray<UStartingSet*> StartingSet = TArray<UStartingSet*>();

		// visit methods
		virtual void Visit(URpgGameDataProjectSettings& Document) override;
		virtual void Visit(UParameter& Document) override;
		virtual void Visit(UParameterValue& Document) override;
		virtual void Visit(UProvision& Document) override;
		virtual void Visit(UHero& Document) override;
		virtual void Visit(UItem& Document) override;
		virtual void Visit(ULocation& Document) override;
		virtual void Visit(UTrinket& Document) override;
		virtual void Visit(UMonster& Document) override;
		virtual void Visit(ULoot& Document) override;
		virtual void Visit(UCombatEffect& Document) override;
		virtual void Visit(UCurioCleansingOption& Document) override;
		virtual void Visit(UCurio& Document) override;
		virtual void Visit(UDisease& Document) override;
		virtual void Visit(UQuirk& Document) override;
		virtual void Visit(UCondition& Document) override;
		virtual void Visit(UWeapon& Document) override;
		virtual void Visit(UArmor& Document) override;
		virtual void Visit(UItemWithCount& Document) override;
		virtual void Visit(UStartingSet& Document) override;
	};

private:
	class FDereferencingVisitor : public FVisitor
	{
		// visit methods
		virtual void Visit(URpgGameDataProjectSettings& Document) override;
		virtual void Visit(UParameter& Document) override;
		virtual void Visit(UParameterValue& Document) override;
		virtual void Visit(UProvision& Document) override;
		virtual void Visit(UHero& Document) override;
		virtual void Visit(UItem& Document) override;
		virtual void Visit(ULocation& Document) override;
		virtual void Visit(UTrinket& Document) override;
		virtual void Visit(UMonster& Document) override;
		virtual void Visit(ULoot& Document) override;
		virtual void Visit(UCombatEffect& Document) override;
		virtual void Visit(UCurioCleansingOption& Document) override;
		virtual void Visit(UCurio& Document) override;
		virtual void Visit(UDisease& Document) override;
		virtual void Visit(UQuirk& Document) override;
		virtual void Visit(UCondition& Document) override;
		virtual void Visit(UWeapon& Document) override;
		virtual void Visit(UArmor& Document) override;
		virtual void Visit(UItemWithCount& Document) override;
		virtual void Visit(UStartingSet& Document) override;
	};

	class FLanguagesUpdateVisitor : public FVisitor
	{
	private:
		const TArray<FString> LanguageIds;

	public:
		FLanguagesUpdateVisitor(const TArray<FString>& LanguageIds);

		// visit methods
		virtual void Visit(URpgGameDataProjectSettings& Document) override;
		virtual void Visit(UParameter& Document) override;
		virtual void Visit(UParameterValue& Document) override;
		virtual void Visit(UProvision& Document) override;
		virtual void Visit(UHero& Document) override;
		virtual void Visit(UItem& Document) override;
		virtual void Visit(ULocation& Document) override;
		virtual void Visit(UTrinket& Document) override;
		virtual void Visit(UMonster& Document) override;
		virtual void Visit(ULoot& Document) override;
		virtual void Visit(UCombatEffect& Document) override;
		virtual void Visit(UCurioCleansingOption& Document) override;
		virtual void Visit(UCurio& Document) override;
		virtual void Visit(UDisease& Document) override;
		virtual void Visit(UQuirk& Document) override;
		virtual void Visit(UCondition& Document) override;
		virtual void Visit(UWeapon& Document) override;
		virtual void Visit(UArmor& Document) override;
		virtual void Visit(UItemWithCount& Document) override;
		virtual void Visit(UStartingSet& Document) override;
		void RemoveExtraKeys(TMap<FString, FText>& TextByLanguageId);
	};
};
