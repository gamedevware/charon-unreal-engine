
//
// The source code was generated by the Charon, GameDevWare, 2026
// License: MIT
//
//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// ReSharper disable All

#include "UConditionsCheckFormula.h"
#include "URpgGameData.h"

DEFINE_LOG_CATEGORY(LogUConditionsCheckFormula);

#if defined(CHARON_FEATURE_FORMULAS) && CHARON_FEATURE_FORMULAS
static TSharedPtr<FFormulaTypeResolver> __TypeResolver;

TSharedRef<FFormulaTypeResolver> GetOrCreateTypeResolver()
{
	if (__TypeResolver.IsValid())
	{
		return  __TypeResolver.ToSharedRef();
	}

	__TypeResolver = MakeShared<FFormulaTypeResolver>(URpgGameData::GetSharedFormulaTypeResolver(), TArray<UObject*> {
		UObject::StaticClass(),
		// FColor <- unknown name prefix
	});

	return __TypeResolver.ToSharedRef();
}

TSharedPtr<TArray<TFieldPath<FProperty>>> UConditionsCheckFormula::GetOrCreateInvokeParameters()
{
	if (!InvokeParameters.IsValid())
	{
		UClass* __FormulaClass = UConditionsCheckFormula::StaticClass();
		UFunction* InvokeFunction = __FormulaClass->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UConditionsCheckFormula, Invoke));
		InvokeParameters = MakeShared<TArray<TFieldPath<FProperty>>>();
		for (TFieldIterator<FProperty> It(InvokeFunction); It; ++It)
		{
			FProperty* Argument = *It;
			InvokeParameters->Add(Argument);
		}
		InvokeParameters->Add(__FormulaClass->FindPropertyByName(GET_MEMBER_NAME_CHECKED(UConditionsCheckFormula, Global)));
	}
	return InvokeParameters;
}
FProperty* UConditionsCheckFormula::GetInvokeParameterAt(int32 Index)
{
	auto Parameters = GetOrCreateInvokeParameters();
	Parameters->RangeCheck(Index);
	auto ParameterFieldPath = Parameters->GetData()[Index];

	check(ParameterFieldPath.Get() != nullptr);

	return ParameterFieldPath.Get();
}

bool UConditionsCheckFormula::Invoke(UObject* Context)
{
	const int32 PARAMETER_CONTEXT_INDEX = 0;
	const int32 RETURN_PARAMETER_INDEX = 1;
	const int32 GLOBAL_PARAMETER_INDEX = 2;

	TSharedPtr<FFormulaExpression> ParsedExpression = this->GetExpression();
	bool __Result = {};
	if (!ParsedExpression.IsValid())
	{
		UE_LOG(LogUConditionsCheckFormula, Error, TEXT("ExpressionTree is missing or invalid."));
		return __Result; // default
	}

	const TMap<FString, FFormulaVariableValue> __Arguments = {
		{ TEXT("context"), FFormulaVariableValue(GetInvokeParameterAt(PARAMETER_CONTEXT_INDEX), &Context ) },
	};

	const FFormulaVariableValue __Global = FFormulaVariableValue(GetInvokeParameterAt(GLOBAL_PARAMETER_INDEX), &this->Global);
	const FFormulaExecutionContext __Context = FFormulaExecutionContext(this->AutoNullPropagation, __Arguments, __Global, GetOrCreateTypeResolver());

	const FFormulaVariableValue __VariableResult = ParsedExpression->Invoke(__Context);
	if (!__VariableResult.TryCopyCompleteValue(GetInvokeParameterAt(RETURN_PARAMETER_INDEX), &__Result))
	{
		UE_LOG(LogUConditionsCheckFormula, Error, TEXT("Failed to convert Formula execution result %s to 'bool' type."), *__VariableResult.ToString());
	}
	return __Result;
}

TSharedPtr<FFormulaExpression> UConditionsCheckFormula::GetExpression()
{
	if (!this->Expression.IsValid() && this->ExpressionTree.JsonObject.IsValid())
	{
		this->Expression = FExpressionBuildHelper::CreateExpression(&this->ExpressionTree.JsonObject);
	}
	return this->Expression;
}
#else
bool UConditionsCheckFormula::Invoke(UObject* Context)
{
	UE_LOG(LogUConditionsCheckFormula, Error, TEXT("Formulas are not supported or disabled in this version of the plugin. Please update the Unreal Engine plugin to the latest version or enable the feature by adding the 'CHARON_FEATURE_FORMULAS=1' compilation constant."));
	return {}; // default
}
#endif
