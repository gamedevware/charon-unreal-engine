
//
// The source code was generated by the Charon, GameDevWare, 2026
// License: MIT
//
//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// ReSharper disable All

#include "UConditionsCheckFormula.h"
#include "URpgGameData.h"

DEFINE_LOG_CATEGORY(LogUConditionsCheckFormula);

#if defined(CHARON_FEATURE_FORMULAS_V2) && CHARON_FEATURE_FORMULAS_V2

TSharedRef<FFormulaTypeResolver> GetOrCreateTypeResolver()
{
	static TSharedRef<FFormulaTypeResolver> __TypeResolver = MakeShared<FFormulaTypeResolver>(URpgGameData::GetSharedFormulaTypeResolver(), TArray<UObject*> {
		UObject::StaticClass(),
		// FColor <- unknown name prefix
	});

	return __TypeResolver;
}

static UFunction* GetInvokeFunction()
{
	static TWeakObjectPtr<UFunction> InvokeFunction = UConditionsCheckFormula::StaticClass()->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UConditionsCheckFormula, Invoke));

	if (!InvokeFunction.IsValid())
	{
		UE_LOG(LogUConditionsCheckFormula, Error, TEXT("Failed to find required 'Invoke' function on 'UConditionsCheckFormula' type."));
	}
	return InvokeFunction.Get();
}

static FProperty* GetGlobalProperty()
{
	static TWeakFieldPtr<FProperty> GlobalProperty = UConditionsCheckFormula::StaticClass()->FindPropertyByName(GET_MEMBER_NAME_CHECKED(UConditionsCheckFormula, Global));

	if (!GlobalProperty.IsValid())
	{
		UE_LOG(LogUConditionsCheckFormula, Error, TEXT("Failed to find required 'Global' property on 'UConditionsCheckFormula' type."));
	}
	return GlobalProperty.Get();
}

static FProperty* GetInvokeParameterAt(int32 Index)
{
	static TArray<FProperty*> Parameters = []()
	{
		TArray<FProperty*> Params;
		for (TFieldIterator<FProperty> It(GetInvokeFunction()); It; ++It)
		{
			FProperty* Prop = *It;

			if (Prop->HasAnyPropertyFlags(CPF_Parm) && !Prop->HasAnyPropertyFlags(CPF_ReturnParm))
			{
				Params.Add(Prop);
			}
		}
		return Params;
	}();

	check(Index >= 0 && Index < Parameters.Num());
	return Parameters[Index];
}

bool UConditionsCheckFormula::Invoke(UObject* Context) const
{
	const int32 PARAMETER_CONTEXT_INDEX = 0;

	auto __ParsedExpression = this->GetExpression();
	auto __InvokeFunction = GetInvokeFunction();

	bool __Result = {};
	if (!__ParsedExpression.IsValid() || !__InvokeFunction)
	{
		UE_LOG(LogUConditionsCheckFormula, Error, TEXT("The expression tree is missing or contains errors, or the function metadata is not available."));
		return __Result; // default
	}

	const TMap<FString, const TSharedRef<FFormulaValue>> __Arguments = {
		{ TEXT("context"), MakeShared<FFormulaValue>(GetInvokeParameterAt(PARAMETER_CONTEXT_INDEX), &Context ) },
	};

	auto __Global = MakeShared<FFormulaValue>(GetGlobalProperty(), &this->Global);
	auto __Context = FFormulaExecutionContext(this->AutoNullPropagation, __Arguments, __Global, GetOrCreateTypeResolver());

	auto __ReturnValueType = __InvokeFunction->GetReturnProperty();
	auto __InvokeResult = __ParsedExpression->Execute(__Context, __ReturnValueType);
	if (__InvokeResult.HasError())
	{
		UE_LOG(LogUConditionsCheckFormula, Error, TEXT("The formula [%s] execution failed. In this case, the default 'bool' result will be returned. Error: %s"), *__ParsedExpression->ToString(), *__InvokeResult.GetError().Message);
	}
	else if (!__InvokeResult.GetValue()->TryCopyCompleteValue(__ReturnValueType, &__Result))
	{
		UE_LOG(LogUConditionsCheckFormula, Error, TEXT("Failed to convert Formula execution result '%s' to 'bool' type."), *__InvokeResult.GetValue()->ToString());
	}
	return __Result;
}

TSharedPtr<FFormulaExpression> UConditionsCheckFormula::GetExpression() const
{
	if (!this->Expression.IsValid() && this->ExpressionTree.JsonObject.IsValid())
	{
		this->Expression = FExpressionBuildHelper::CreateExpression(&this->ExpressionTree.JsonObject);
	}
	return this->Expression;
}
#else
bool UConditionsCheckFormula::Invoke(UObject* Context) const
{
	UE_LOG(LogUConditionsCheckFormula, Error, TEXT("Formulas are not supported or disabled in this version of the plugin. Please update the Unreal Engine plugin to the latest version or enable the feature by adding the 'CHARON_FEATURE_FORMULAS_V2=1' compilation constant."));
	return {}; // default
}
#endif
