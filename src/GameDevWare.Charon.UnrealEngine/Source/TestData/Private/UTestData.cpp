
//
// The source code was generated by the Charon, GameDevWare, 2024
// License: MIT
//
//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All

#include "UTestData.h"
#include "UTestDataProjectSettings.h"
#include "UTestEntity.h"
#include "URecursiveEntity.h"
#include "UNumberTestEntity.h"
#include "UUniqueAttributeEntity.h"
#include "UTestEntityFormulaFieldFormula.h"

DEFINE_LOG_CATEGORY(LogUTestData);

void UTestData::Empty()
{
	for (const auto SubObject: GetRootDocuments())
	{
		SubObject->Rename(nullptr, GetTransientPackage(), 0); // detach sub-documents
	}

	LanguageSwitcher = nullptr;
	RootDocuments = nullptr;
	AllDocuments = nullptr;

	ChangeNumber = 0;
	RevisionHash.Empty();

	ProjectSettings = nullptr;
	AllProjectSettingsList.Empty();
	ProjectSettingsList.Empty();
	AllTestEntities.Empty();
	TestEntities.Empty();
	AllRecursiveEntities.Empty();
	RecursiveEntities.Empty();
	AllNumberTestEntities.Empty();
	NumberTestEntities.Empty();
	AllUniqueAttributeEntities.Empty();
	UniqueAttributeEntities.Empty();

	SupportedLanguages.Empty();
}

bool UTestData::TryLoad(FArchive* const GameDataStream, EGameDataFormat Format)
{
	auto Options = FGameDataLoadOptions();
	Options.Format = Format;
	return TryLoad(GameDataStream, Options);
}
bool UTestData::TryLoad(FArchive* const GameDataStream, FGameDataLoadOptions Options)
{
	Empty(); // Reset current state

	SupportedLanguages.Add(TEXT("ru-RU"));

	if (LanguageSwitcher == nullptr)
	{
		LanguageSwitcher = NewObject<ULanguageSwitcher>(this);
	}
	LanguageSwitcher->CurrentLanguageId = TEXT("ru-RU");
	LanguageSwitcher->FallbackLanguageId = TEXT("ru-RU");
	LanguageSwitcher->PrimaryLanguageId = TEXT("ru-RU");

	auto GameDataReader = CreateReader(GameDataStream, Options);
	GameDataReader->ReadNext(); // initialize reader and move to first token

	if (Options.Patches.Num() > 0)
	{
		TSharedPtr<FJsonObject> GameDataDocument = nullptr;
		if (!GameDataReader->ReadObject(GameDataDocument, /* NextToken */  false))
		{
			GameDataDocument = nullptr;
			UE_LOG(LogUTestData, Error, TEXT("Failed to read Game Data from file. Probably file format is wrong or file is broken."));
			return false;
		}
		for (const auto GameDataPatchStream : Options.Patches)
		{
			const auto GameDataPatchReader = CreateReader(GameDataPatchStream, Options);
			GameDataPatchReader->ReadNext(); // initialize reader and move to first token

			TSharedPtr<FJsonObject> GameDataPatchDocument;
			if (!GameDataPatchReader->ReadObject(GameDataPatchDocument, /* NextToken */  false))
			{
				GameDataPatchDocument = nullptr;
				UE_LOG(LogUTestData, Error, TEXT("Failed to read Game Data patch from file. Probably file format is wrong or file is broken."));
				return false;
			}

			GameDataDocument = MergeGameData(GameDataDocument, GameDataPatchDocument);
		}

		if (GameDataDocument == nullptr)
		{
			UE_LOG(LogUTestData, Error, TEXT("Failed to apply Game Data patch."));
			return false;
		}

		GameDataReader = FGameDataReaderFactory::CreateJsonObjectReader(GameDataDocument);
		GameDataReader->ReadNext(); // initialize reader and move to first token
	}

	if (!ReadGameData(GameDataReader))
	{
		UE_LOG(LogUTestData, Error, TEXT("Failed to parse Game Data from file."));
		return false;
	}

	FindAllDocuments();
	UpdateProjectSettings();
	UpdateSettings();

	return true;
}

void UTestData::UpdateProjectSettings()
{
	const auto _ProjectSettings = GetOne(this->ProjectSettingsList);
	if (_ProjectSettings == nullptr)
	{
		return;
	}
	GameDataVersion = _ProjectSettings->Version;

	const auto _ProjectSettingsLanguages = _ProjectSettings->Languages;
	if (_ProjectSettingsLanguages.IsEmpty())
	{
		return;
	}

	SupportedLanguages.Empty();

	ParseLanguageList(_ProjectSettingsLanguages, SupportedLanguages);

	const auto _ProjectSettingsPrimaryLanguage = _ProjectSettings->PrimaryLanguage;
	if (!_ProjectSettingsPrimaryLanguage.IsEmpty())
	{
		LanguageSwitcher->PrimaryLanguageId = _ProjectSettingsPrimaryLanguage;
	}
	else if (SupportedLanguages.Num() > 0)
	{
		LanguageSwitcher->PrimaryLanguageId = SupportedLanguages[0];
	}
	else
	{
		LanguageSwitcher->PrimaryLanguageId = TEXT("ru-RU");
	}

	LanguageSwitcher->CurrentLanguageId = LanguageSwitcher->FallbackLanguageId = LanguageSwitcher->PrimaryLanguageId;
	if (!SupportedLanguages.Contains(LanguageSwitcher->PrimaryLanguageId))
	{
		SupportedLanguages.Add(LanguageSwitcher->PrimaryLanguageId);
	}
	SupportedLanguages.Sort();
}

void UTestData::ParseLanguageList(const FString& InLanguages, TArray<FString>& OutLanguageList)
{
	auto Languages = FString(InLanguages);
	Languages.ReplaceCharInline(TEXT(','), TEXT(';'));
	Languages.ReplaceCharInline(TEXT('|'), TEXT(';'));
	Languages.ReplaceCharInline(TEXT(' '), TEXT(';'));
	Languages.ParseIntoArray(OutLanguageList, TEXT(";"), /* inCullEmpty */ true);
}

void UTestData::UpdateSettings()
{
	this->ProjectSettings = GetOne(this->ProjectSettingsList);
}

const TArray<UGameDataDocument*>& UTestData::GetAllDocuments() const
{
	if (AllDocuments != nullptr)
	{
		return AllDocuments.ToSharedRef().Get();
	}

	const auto FoundDocuments = MakeShared<TArray<UGameDataDocument*>>();
	for (const auto DocumentById : AllProjectSettingsList)
	{
		FoundDocuments->Add(DocumentById.Value);
	}
	for (const auto DocumentById : AllTestEntities)
	{
		FoundDocuments->Add(DocumentById.Value);
	}
	for (const auto DocumentById : AllRecursiveEntities)
	{
		FoundDocuments->Add(DocumentById.Value);
	}
	for (const auto DocumentById : AllNumberTestEntities)
	{
		FoundDocuments->Add(DocumentById.Value);
	}
	for (const auto DocumentById : AllUniqueAttributeEntities)
	{
		FoundDocuments->Add(DocumentById.Value);
	}
	const_cast<UTestData*>(this)->AllDocuments = FoundDocuments;
	return FoundDocuments.Get();
}

const TArray<UGameDataDocument*>& UTestData::GetRootDocuments() const
{
	if (RootDocuments != nullptr)
	{
		return RootDocuments.ToSharedRef().Get();
	}

	const auto FoundDocuments = MakeShared<TArray<UGameDataDocument*>>();
	for (const auto DocumentById : ProjectSettingsList)
	{
		FoundDocuments->Add(DocumentById.Value);
	}
	for (const auto DocumentById : TestEntities)
	{
		FoundDocuments->Add(DocumentById.Value);
	}
	for (const auto DocumentById : RecursiveEntities)
	{
		FoundDocuments->Add(DocumentById.Value);
	}
	for (const auto DocumentById : NumberTestEntities)
	{
		FoundDocuments->Add(DocumentById.Value);
	}
	for (const auto DocumentById : UniqueAttributeEntities)
	{
		FoundDocuments->Add(DocumentById.Value);
	}
	const_cast<UTestData*>(this)->RootDocuments = FoundDocuments;
	return FoundDocuments.Get();
}

template <typename IdType, typename DocumentType>
DocumentType* UTestData::GetOne(const TMap<IdType, DocumentType*>& Documents) const
{
	if (Documents.Num() == 1)
	{
        auto Iterator = Documents.CreateConstIterator();
        return Iterator->Value;
	}
	return nullptr;
}

template <typename IdType, typename DocumentType>
void UTestData::ToMapById(TMap<IdType, DocumentType*>& DocumentsById, TArray<DocumentType*>& Documents)
{
	for (auto Document : Documents)
	{
		DocumentsById.FindOrAdd(Document->Id, Document);
	}
}

UGameDataDocument* UTestData::FindGameDataDocumentById(const FString& SchemaNameOrId, const FString& DocumentId)
{
	if (SchemaNameOrId.IsEmpty() || DocumentId.IsEmpty())
	{
		return nullptr;
	}
	else if (SchemaNameOrId == TEXT("ProjectSettings") || SchemaNameOrId == TEXT("55a4f32faca22e191098f3d9"))
	{
		FString Id;
		FGameDataDocumentIdConvert::ConvertToType(DocumentId, Id);
		const auto FoundDocument = this->AllProjectSettingsList.Find(Id);
		if (FoundDocument != nullptr)
		{
			return *FoundDocument;
		}
	}
	else if (SchemaNameOrId == TEXT("TestEntity") || SchemaNameOrId == TEXT("592fc86c983a36266c0912a0"))
	{
		FString Id;
		FGameDataDocumentIdConvert::ConvertToType(DocumentId, Id);
		const auto FoundDocument = this->AllTestEntities.Find(Id);
		if (FoundDocument != nullptr)
		{
			return *FoundDocument;
		}
	}
	else if (SchemaNameOrId == TEXT("RecursiveEntity") || SchemaNameOrId == TEXT("592fc894983a36266c0912a4"))
	{
		FString Id;
		FGameDataDocumentIdConvert::ConvertToType(DocumentId, Id);
		const auto FoundDocument = this->AllRecursiveEntities.Find(Id);
		if (FoundDocument != nullptr)
		{
			return *FoundDocument;
		}
	}
	else if (SchemaNameOrId == TEXT("NumberTestEntity") || SchemaNameOrId == TEXT("592fdb43983a3619c016b696"))
	{
		int32 Id;
		FGameDataDocumentIdConvert::ConvertToType(DocumentId, Id);
		const auto FoundDocument = this->AllNumberTestEntities.Find(Id);
		if (FoundDocument != nullptr)
		{
			return *FoundDocument;
		}
	}
	else if (SchemaNameOrId == TEXT("UniqueAttributeEntity") || SchemaNameOrId == TEXT("65d3565e27363a98010000ec"))
	{
		FString Id;
		FGameDataDocumentIdConvert::ConvertToType(DocumentId, Id);
		const auto FoundDocument = this->AllUniqueAttributeEntities.Find(Id);
		if (FoundDocument != nullptr)
		{
			return *FoundDocument;
		}
	}
	return nullptr;
}

UClass* UTestData::FindDocumentSchemaClass(const FString& SchemaNameOrId)
{
	if (SchemaNameOrId.IsEmpty())
	{
		return nullptr;
	}
	else if (SchemaNameOrId == TEXT("ProjectSettings") || SchemaNameOrId == TEXT("55a4f32faca22e191098f3d9"))
	{
		return UTestDataProjectSettings::StaticClass();
	}
	else if (SchemaNameOrId == TEXT("TestEntity") || SchemaNameOrId == TEXT("592fc86c983a36266c0912a0"))
	{
		return UTestEntity::StaticClass();
	}
	else if (SchemaNameOrId == TEXT("RecursiveEntity") || SchemaNameOrId == TEXT("592fc894983a36266c0912a4"))
	{
		return URecursiveEntity::StaticClass();
	}
	else if (SchemaNameOrId == TEXT("NumberTestEntity") || SchemaNameOrId == TEXT("592fdb43983a3619c016b696"))
	{
		return UNumberTestEntity::StaticClass();
	}
	else if (SchemaNameOrId == TEXT("UniqueAttributeEntity") || SchemaNameOrId == TEXT("65d3565e27363a98010000ec"))
	{
		return UUniqueAttributeEntity::StaticClass();
	}
	return nullptr;
}

void UTestData::GetDocumentIds(const FString& SchemaNameOrId, TArray<FString>& AllIds)
{
	if (SchemaNameOrId.IsEmpty())
	{
		return;
	}
	else if (SchemaNameOrId == TEXT("ProjectSettings") || SchemaNameOrId == TEXT("55a4f32faca22e191098f3d9"))
	{
		for (auto DocumentById : AllProjectSettingsList)
		{
			FString IdString;
			FGameDataDocumentIdConvert::ConvertToString(DocumentById.Key, IdString);
			AllIds.Add(IdString);
		}
	}
	else if (SchemaNameOrId == TEXT("TestEntity") || SchemaNameOrId == TEXT("592fc86c983a36266c0912a0"))
	{
		for (auto DocumentById : AllTestEntities)
		{
			FString IdString;
			FGameDataDocumentIdConvert::ConvertToString(DocumentById.Key, IdString);
			AllIds.Add(IdString);
		}
	}
	else if (SchemaNameOrId == TEXT("RecursiveEntity") || SchemaNameOrId == TEXT("592fc894983a36266c0912a4"))
	{
		for (auto DocumentById : AllRecursiveEntities)
		{
			FString IdString;
			FGameDataDocumentIdConvert::ConvertToString(DocumentById.Key, IdString);
			AllIds.Add(IdString);
		}
	}
	else if (SchemaNameOrId == TEXT("NumberTestEntity") || SchemaNameOrId == TEXT("592fdb43983a3619c016b696"))
	{
		for (auto DocumentById : AllNumberTestEntities)
		{
			FString IdString;
			FGameDataDocumentIdConvert::ConvertToString(DocumentById.Key, IdString);
			AllIds.Add(IdString);
		}
	}
	else if (SchemaNameOrId == TEXT("UniqueAttributeEntity") || SchemaNameOrId == TEXT("65d3565e27363a98010000ec"))
	{
		for (auto DocumentById : AllUniqueAttributeEntities)
		{
			FString IdString;
			FGameDataDocumentIdConvert::ConvertToString(DocumentById.Key, IdString);
			AllIds.Add(IdString);
		}
	}
}

void UTestData::GetDocumentSchemaNames(TArray<FString>& AllSchemaNames)
{
	AllSchemaNames.Add(TEXT("ProjectSettings"));
	AllSchemaNames.Add(TEXT("TestEntity"));
	AllSchemaNames.Add(TEXT("RecursiveEntity"));
	AllSchemaNames.Add(TEXT("NumberTestEntity"));
	AllSchemaNames.Add(TEXT("UniqueAttributeEntity"));
}


TSharedRef<IGameDataReader> UTestData::CreateReader(FArchive* const GameDataStream, const FGameDataLoadOptions& Options)
{
	switch (Options.Format)
	{
	case EGameDataFormat::Json:
		return FGameDataReaderFactory::CreateJsonReader(GameDataStream);
	case EGameDataFormat::MessagePack:
		return FGameDataReaderFactory::CreateMessagePackReader(GameDataStream);
	default:
		UE_LOG(LogUTestData, Error, TEXT("Unknown game data format specified in FGameDataLoadOptions. Fallback to JSON formatter."));
		return FGameDataReaderFactory::CreateJsonReader(GameDataStream);
	}
}

bool UTestData::ReadGameData(const TSharedRef<IGameDataReader>& Reader)
{
	auto GameDataPath = TArray<FString>();
	GameDataPath.Add(TEXT(""));

	if (!Reader->ReadObjectBegin())
	{
		UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
		return false;
	}

	while (Reader->GetNotation() != EJsonNotation::ObjectEnd)
	{
		if (Reader->IsError())
		{
			UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
			return false;
		}

		auto MemberName = Reader->ReadMember();
		if (MemberName == TEXT("ChangeNumber"))
		{
			Reader->ReadValue(ChangeNumber);
			Reader->ReadNext();
		}
		else if (MemberName == TEXT("RevisionHash"))
		{
			Reader->ReadValue(RevisionHash);
			Reader->ReadNext();
		}
		else if (MemberName == TEXT("Collections"))
		{
			GameDataPath.Add(TEXT("Collections"));
			Reader->ReadObjectBegin();
			while (Reader->GetNotation() != EJsonNotation::ObjectEnd)
			{
				if (Reader->IsError())
				{
					UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
					return false;
				}

				auto CollectionName = Reader->ReadMember();
				GameDataPath.Add(CollectionName);
				switch (CollectionName.Len())
				{
					case 10:
						if (CollectionName.IsEmpty())
						{
							Reader->SkipAny();
						}
						else if (CollectionName == TEXT("592fc86c983a36266c0912a0") || CollectionName == TEXT("TestEntity"))
						{
							GameDataPath.Add(TEXT("TestEntity"));
							if (!ReadDocumentCollection(Reader, this->TestEntities, 1, this, GameDataPath))
							{
								UE_LOG(LogUTestData, Error, TEXT("Failed to read '%s' document collection. Path: %s."), TEXT("TestEntity"), *CombineGameDataPath(GameDataPath));
								return false;
							}
							GameDataPath.Pop();
						}
						else
						{
							Reader->SkipAny();
						}
						break;
					case 15:
						if (CollectionName.IsEmpty())
						{
							Reader->SkipAny();
						}
						else if (CollectionName == TEXT("55a4f32faca22e191098f3d9") || CollectionName == TEXT("ProjectSettings"))
						{
							GameDataPath.Add(TEXT("ProjectSettings"));
							if (!ReadDocumentCollection(Reader, this->ProjectSettingsList, 1, this, GameDataPath))
							{
								UE_LOG(LogUTestData, Error, TEXT("Failed to read '%s' document collection. Path: %s."), TEXT("ProjectSettings"), *CombineGameDataPath(GameDataPath));
								return false;
							}
							GameDataPath.Pop();
						}
						else if (CollectionName == TEXT("592fc894983a36266c0912a4") || CollectionName == TEXT("RecursiveEntity"))
						{
							GameDataPath.Add(TEXT("RecursiveEntity"));
							if (!ReadDocumentCollection(Reader, this->RecursiveEntities, 1, this, GameDataPath))
							{
								UE_LOG(LogUTestData, Error, TEXT("Failed to read '%s' document collection. Path: %s."), TEXT("RecursiveEntity"), *CombineGameDataPath(GameDataPath));
								return false;
							}
							GameDataPath.Pop();
						}
						else
						{
							Reader->SkipAny();
						}
						break;
					case 16:
						if (CollectionName.IsEmpty())
						{
							Reader->SkipAny();
						}
						else if (CollectionName == TEXT("592fdb43983a3619c016b696") || CollectionName == TEXT("NumberTestEntity"))
						{
							GameDataPath.Add(TEXT("NumberTestEntity"));
							if (!ReadDocumentCollection(Reader, this->NumberTestEntities, 2, this, GameDataPath))
							{
								UE_LOG(LogUTestData, Error, TEXT("Failed to read '%s' document collection. Path: %s."), TEXT("NumberTestEntity"), *CombineGameDataPath(GameDataPath));
								return false;
							}
							GameDataPath.Pop();
						}
						else
						{
							Reader->SkipAny();
						}
						break;
					case 21:
						if (CollectionName.IsEmpty())
						{
							Reader->SkipAny();
						}
						else if (CollectionName == TEXT("65d3565e27363a98010000ec") || CollectionName == TEXT("UniqueAttributeEntity"))
						{
							GameDataPath.Add(TEXT("UniqueAttributeEntity"));
							if (!ReadDocumentCollection(Reader, this->UniqueAttributeEntities, 1, this, GameDataPath))
							{
								UE_LOG(LogUTestData, Error, TEXT("Failed to read '%s' document collection. Path: %s."), TEXT("UniqueAttributeEntity"), *CombineGameDataPath(GameDataPath));
								return false;
							}
							GameDataPath.Pop();
						}
						else
						{
							Reader->SkipAny();
						}
						break;
					default:
						Reader->SkipAny();
						break;
				}
			}
			Reader->ReadObjectEnd();
			GameDataPath.Pop();
			break;
		}
		else
		{
			Reader->SkipAny();
		}
	}
	Reader->ReadObjectEnd();
	GameDataPath.Pop();

	if (Reader->IsError())
	{
		UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
		return false;
	}

	return true;
}
bool UTestData::ReadDocument
(
	const TSharedRef<IGameDataReader>& Reader,
	UTestDataProjectSettings*& Document,
	UObject* Outer,
	TArray<FString>& GameDataPath,
	bool NextToken
)
{
	Document = NewObject<UTestDataProjectSettings>(Outer, UTestDataProjectSettings::StaticClass(), NAME_None, RF_Transactional);
	Outer = Document;

	Reader->ReadObjectBegin();
	while (Reader->GetNotation() != EJsonNotation::ObjectEnd)
	{
		if (Reader->IsError())
		{
			UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
			return false;
		}

		auto PropertyName = Reader->ReadMember();
		bool bReadSuccess;
		GameDataPath.Add(PropertyName);
		if (PropertyName.IsEmpty())
		{
			Reader->SkipAny();
		}
		else if (PropertyName == TEXT("Id"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("ProjectSettings.Id"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->Id) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("ProjectSettings.Id"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			FString NewName;
			FGameDataDocumentIdConvert::ConvertToString(Document->Id, NewName);
			NewName.InsertAt(0, TEXT("TestDataProjectSettings_"));

			UObject* ExistingObject = StaticFindObject(/*Class=*/ nullptr, Outer, *NewName, true);
			if (ExistingObject)
			{
				ExistingObject->Rename(nullptr, GetTransientPackage(), 0); // detach existing document
			}

			Document->Rename(*NewName, nullptr, REN_DoNotDirty | REN_DontCreateRedirectors | REN_ForceNoResetLoaders);
		}
		else if (PropertyName == TEXT("Name"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("ProjectSettings.Name"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->Name) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("ProjectSettings.Name"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("PrimaryLanguage"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->PrimaryLanguage) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("ProjectSettings.PrimaryLanguage"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("Languages"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->Languages) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("ProjectSettings.Languages"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("Copyright"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->Copyright) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("ProjectSettings.Copyright"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("Version"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("ProjectSettings.Version"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->Version) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("ProjectSettings.Version"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else
		{
			Reader->SkipAny();
		}
		GameDataPath.Pop();
	}
	Reader->ReadObjectEnd(NextToken);

	if (Reader->IsError())
	{
		UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
		return false;
	}

	return true;
}
bool UTestData::ReadDocument
(
	const TSharedRef<IGameDataReader>& Reader,
	UTestEntity*& Document,
	UObject* Outer,
	TArray<FString>& GameDataPath,
	bool NextToken
)
{
	Document = NewObject<UTestEntity>(Outer, UTestEntity::StaticClass(), NAME_None, RF_Transactional);
	Outer = Document;

	Reader->ReadObjectBegin();
	while (Reader->GetNotation() != EJsonNotation::ObjectEnd)
	{
		if (Reader->IsError())
		{
			UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
			return false;
		}

		auto PropertyName = Reader->ReadMember();
		bool bReadSuccess;
		GameDataPath.Add(PropertyName);
		if (PropertyName.IsEmpty())
		{
			Reader->SkipAny();
		}
		else if (PropertyName == TEXT("Id"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("TestEntity.Id"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->Id) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.Id"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			FString NewName;
			FGameDataDocumentIdConvert::ConvertToString(Document->Id, NewName);
			NewName.InsertAt(0, TEXT("TestEntity_"));

			UObject* ExistingObject = StaticFindObject(/*Class=*/ nullptr, Outer, *NewName, true);
			if (ExistingObject)
			{
				ExistingObject->Rename(nullptr, GetTransientPackage(), 0); // detach existing document
			}

			Document->Rename(*NewName, nullptr, REN_DoNotDirty | REN_DontCreateRedirectors | REN_ForceNoResetLoaders);
		}
		else if (PropertyName == TEXT("TextField"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->TextField) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.TextField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("LocalizedTextField"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = ReadLocalizedText(Reader, Document->LocalizedTextFieldRaw, GameDataPath);
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.LocalizedTextField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("LogicalField"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->LogicalField) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.LogicalField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("TimeField"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->TimeField) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.TimeField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("DateField"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->DateField) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.DateField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("NumberField"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->NumberField) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.NumberField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("NumberFieldX64"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("TestEntity.NumberFieldX64"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->NumberFieldX64) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.NumberFieldX64"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("IntegerField"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->IntegerField) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.IntegerField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("IntegerFieldX64"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("TestEntity.IntegerFieldX64"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->IntegerFieldX64) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.IntegerFieldX64"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("PickListField"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->PickListField) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.PickListField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("MultiPickListField"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->MultiPickListField) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.MultiPickListField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("DocumentField"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = ReadDocument(Reader, Document->DocumentField, Outer, GameDataPath);
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.DocumentField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("ListOfDocumentsField"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("TestEntity.ListOfDocumentsField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = ReadDocumentCollection(Reader, Document->ListOfDocumentsField, 0, Outer, GameDataPath);
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.ListOfDocumentsField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("ReferenceField"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = ReadDocumentReference(Reader, Document->ReferenceFieldRaw, TEXT("TestEntity"), GameDataPath);
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.ReferenceField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("ListOfReferencesField"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("TestEntity.ListOfReferencesField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = ReadDocumentReferenceCollection(Reader, Document->ListOfReferencesFieldRaw, TEXT("TestEntity"), GameDataPath);
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.ListOfReferencesField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("FormulaField"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = ReadFormula(Reader, Document->FormulaField, Outer, GameDataPath);
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.FormulaField"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("IsPublished"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("TestEntity.IsPublished"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->IsPublished) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("TestEntity.IsPublished"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else
		{
			Reader->SkipAny();
		}
		GameDataPath.Pop();
	}
	Reader->ReadObjectEnd(NextToken);

	if (Reader->IsError())
	{
		UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
		return false;
	}

	return true;
}
bool UTestData::ReadDocument
(
	const TSharedRef<IGameDataReader>& Reader,
	URecursiveEntity*& Document,
	UObject* Outer,
	TArray<FString>& GameDataPath,
	bool NextToken
)
{
	Document = NewObject<URecursiveEntity>(Outer, URecursiveEntity::StaticClass(), NAME_None, RF_Transactional);
	Outer = Document;

	Reader->ReadObjectBegin();
	while (Reader->GetNotation() != EJsonNotation::ObjectEnd)
	{
		if (Reader->IsError())
		{
			UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
			return false;
		}

		auto PropertyName = Reader->ReadMember();
		bool bReadSuccess;
		GameDataPath.Add(PropertyName);
		if (PropertyName.IsEmpty())
		{
			Reader->SkipAny();
		}
		else if (PropertyName == TEXT("Id"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("RecursiveEntity.Id"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->Id) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("RecursiveEntity.Id"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			FString NewName;
			FGameDataDocumentIdConvert::ConvertToString(Document->Id, NewName);
			NewName.InsertAt(0, TEXT("RecursiveEntity_"));

			UObject* ExistingObject = StaticFindObject(/*Class=*/ nullptr, Outer, *NewName, true);
			if (ExistingObject)
			{
				ExistingObject->Rename(nullptr, GetTransientPackage(), 0); // detach existing document
			}

			Document->Rename(*NewName, nullptr, REN_DoNotDirty | REN_DontCreateRedirectors | REN_ForceNoResetLoaders);
		}
		else if (PropertyName == TEXT("Title"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("RecursiveEntity.Title"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->Title) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("RecursiveEntity.Title"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("Children"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("RecursiveEntity.Children"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = ReadDocumentCollection(Reader, Document->Children, 0, Outer, GameDataPath);
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("RecursiveEntity.Children"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else
		{
			Reader->SkipAny();
		}
		GameDataPath.Pop();
	}
	Reader->ReadObjectEnd(NextToken);

	if (Reader->IsError())
	{
		UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
		return false;
	}

	return true;
}
bool UTestData::ReadDocument
(
	const TSharedRef<IGameDataReader>& Reader,
	UNumberTestEntity*& Document,
	UObject* Outer,
	TArray<FString>& GameDataPath,
	bool NextToken
)
{
	Document = NewObject<UNumberTestEntity>(Outer, UNumberTestEntity::StaticClass(), NAME_None, RF_Transactional);
	Outer = Document;

	Reader->ReadObjectBegin();
	while (Reader->GetNotation() != EJsonNotation::ObjectEnd)
	{
		if (Reader->IsError())
		{
			UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
			return false;
		}

		auto PropertyName = Reader->ReadMember();
		bool bReadSuccess;
		GameDataPath.Add(PropertyName);
		if (PropertyName.IsEmpty())
		{
			Reader->SkipAny();
		}
		else if (PropertyName == TEXT("Id"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.Id"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->Id) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.Id"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			FString NewName;
			FGameDataDocumentIdConvert::ConvertToString(Document->Id, NewName);
			NewName.InsertAt(0, TEXT("NumberTestEntity_"));

			UObject* ExistingObject = StaticFindObject(/*Class=*/ nullptr, Outer, *NewName, true);
			if (ExistingObject)
			{
				ExistingObject->Rename(nullptr, GetTransientPackage(), 0); // detach existing document
			}

			Document->Rename(*NewName, nullptr, REN_DoNotDirty | REN_DontCreateRedirectors | REN_ForceNoResetLoaders);
		}
		else if (PropertyName == TEXT("Number32Bit"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.Number32Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->Number32Bit) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.Number32Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("Number64Bit"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.Number64Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->Number64Bit) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.Number64Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("Integer8Bit"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.Integer8Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->Integer8Bit) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.Integer8Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("Integer16Bit"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.Integer16Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->Integer16Bit) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.Integer16Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("Integer32Bit"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.Integer32Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->Integer32Bit) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.Integer32Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("Integer64Bit"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.Integer64Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->Integer64Bit) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.Integer64Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("PickList8Bit"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.PickList8Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->PickList8Bit) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.PickList8Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("PickList16Bit"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.PickList16Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->PickList16Bit) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.PickList16Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("PickList32Bit"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.PickList32Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->PickList32Bit) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.PickList32Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("PickList64Bit"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.PickList64Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->PickList64Bit) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.PickList64Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("MultiPickList8Bit"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.MultiPickList8Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->MultiPickList8Bit) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.MultiPickList8Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("MultiPickList16Bit"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.MultiPickList16Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->MultiPickList16Bit) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.MultiPickList16Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("MultiPickList32Bit"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.MultiPickList32Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->MultiPickList32Bit) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.MultiPickList32Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("MultiPickList64Bit"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.MultiPickList64Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->MultiPickList64Bit) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("NumberTestEntity.MultiPickList64Bit"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else
		{
			Reader->SkipAny();
		}
		GameDataPath.Pop();
	}
	Reader->ReadObjectEnd(NextToken);

	if (Reader->IsError())
	{
		UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
		return false;
	}

	return true;
}
bool UTestData::ReadDocument
(
	const TSharedRef<IGameDataReader>& Reader,
	UUniqueAttributeEntity*& Document,
	UObject* Outer,
	TArray<FString>& GameDataPath,
	bool NextToken
)
{
	Document = NewObject<UUniqueAttributeEntity>(Outer, UUniqueAttributeEntity::StaticClass(), NAME_None, RF_Transactional);
	Outer = Document;

	Reader->ReadObjectBegin();
	while (Reader->GetNotation() != EJsonNotation::ObjectEnd)
	{
		if (Reader->IsError())
		{
			UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
			return false;
		}

		auto PropertyName = Reader->ReadMember();
		bool bReadSuccess;
		GameDataPath.Add(PropertyName);
		if (PropertyName.IsEmpty())
		{
			Reader->SkipAny();
		}
		else if (PropertyName == TEXT("Id"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.Id"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->Id) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.Id"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			FString NewName;
			FGameDataDocumentIdConvert::ConvertToString(Document->Id, NewName);
			NewName.InsertAt(0, TEXT("UniqueAttributeEntity_"));

			UObject* ExistingObject = StaticFindObject(/*Class=*/ nullptr, Outer, *NewName, true);
			if (ExistingObject)
			{
				ExistingObject->Rename(nullptr, GetTransientPackage(), 0); // detach existing document
			}

			Document->Rename(*NewName, nullptr, REN_DoNotDirty | REN_DontCreateRedirectors | REN_ForceNoResetLoaders);
		}
		else if (PropertyName == TEXT("snake_case_key"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->SnakeCaseKey) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.SnakeCaseKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("camelCaseKey"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->CamelCaseKey) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.CamelCaseKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("DromedaryCaseKey"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->DromedaryCaseKey) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.DromedaryCaseKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("TextKey"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.TextKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->TextKey) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.TextKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("NonRequiredKey"))
		{
			if (Reader->IsNull())
			{
				Reader->ReadNext();
				continue;
			}
			bReadSuccess = Reader->ReadValue(Document->NonRequiredKey) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.NonRequiredKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("NumberKey"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.NumberKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->NumberKey) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.NumberKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("IntegerKey"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.IntegerKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->IntegerKey) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.IntegerKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("PickListKey"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.PickListKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->PickListKey) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.PickListKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("MultiPickListKey"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.MultiPickListKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->MultiPickListKey) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.MultiPickListKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("TimeSpanKey"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.TimeSpanKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->TimeSpanKey) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.TimeSpanKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else if (PropertyName == TEXT("DateTimeKey"))
		{
			if (Reader->IsNull())
			{
				UE_LOG(LogUTestData, Error, TEXT("Unexpected null value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.DateTimeKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
			bReadSuccess = Reader->ReadValue(Document->DateTimeKey) && Reader->ReadNext();
			if (!bReadSuccess)
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read value for property '%s' of document. Path: %s."), TEXT("UniqueAttributeEntity.DateTimeKey"), *CombineGameDataPath(GameDataPath));
				return false;
			}
		}
		else
		{
			Reader->SkipAny();
		}
		GameDataPath.Pop();
	}
	Reader->ReadObjectEnd(NextToken);

	if (Reader->IsError())
	{
		UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
		return false;
	}

	return true;
}
template <typename IdType, typename DocumentType>
bool UTestData::ReadDocumentCollection
(
	const TSharedRef<IGameDataReader>& Reader,
	TMap<IdType,DocumentType*>& Collection,
	int32 Capacity,
	UObject* Outer,
	TArray<FString>& GameDataPath,
	bool NextToken
)
{
	Collection.Empty();
	if (Reader->IsNull())
	{
		return true;
	}

	const bool IsByIdCollection = Reader->GetNotation() == EJsonNotation::ObjectStart;
	auto Documents = TArray<DocumentType*>();

	if (Capacity > 0)
	{
		Documents.Reserve(Capacity);
	}

	if (IsByIdCollection)
	{
		Reader->ReadObjectBegin();
	}
	else
	{
		Reader->ReadArrayBegin();
	}

	int32 Count = -1;
	while (Reader->GetNotation() != EJsonNotation::ArrayEnd &&
			Reader->GetNotation() != EJsonNotation::ObjectEnd)
	{
		Count++;

		if (Reader->IsError())
		{
			UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
			return false;
		}
		if (Reader->IsNull())
		{
			Reader->ReadNext();
			continue;
		}

		auto DocumentId = Reader->GetIdentifier();
		if (!DocumentId.IsEmpty())
		{
			GameDataPath.Add(DocumentId);
		}
		else
		{
			GameDataPath.Add(FString::FromInt(Count));
		}

		DocumentType* Document = nullptr;
		if (ReadDocument(Reader, Document, Outer, GameDataPath) && Document != nullptr)
		{
			Documents.Add(Document);
		}
		else
		{
			UE_LOG(LogUTestData, Error, TEXT("Failed to read document. Path: %s."), *CombineGameDataPath(GameDataPath));
			return false;
		}

		GameDataPath.Pop();
	}
	if (IsByIdCollection)
	{
		Reader->ReadObjectEnd(NextToken);
	}
	else
	{
		Reader->ReadArrayEnd(NextToken);
	}

	if (Reader->IsError())
	{
		UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
		return false;
	}

	ToMapById(Collection, Documents);

	return true;
}
bool UTestData::ReadLocalizedText
(
	const TSharedRef<IGameDataReader>& Reader,
	FLocalizedText& LocalizedText,
	TArray<FString>& GameDataPath,
	bool NextToken
)
{
	auto LocStringMap = TMap<FString, FText>();
	Reader->ReadObjectBegin();
	while (Reader->GetNotation() != EJsonNotation::ObjectEnd)
	{
		if (Reader->IsError())
		{
			UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
			return false;
		}

		FString LanguageId = Reader->ReadMember();
		if (LanguageId == TEXT("notes")) {
			Reader->SkipAny();
			continue;
		}

		FText Text;
		GameDataPath.Add(LanguageId);
		if (!Reader->ReadValue(Text))
		{
			UE_LOG(LogUTestData, Error, TEXT("Failed to read localized text for language '%s'. Path: %s."), *LanguageId, *CombineGameDataPath(GameDataPath));
			return false;
		}
		Reader->ReadNext();
		GameDataPath.Pop();

		if (LanguageId.IsEmpty() || Text.IsEmpty())
		{
			continue;
		}
		LocStringMap.Add(LanguageId, Text);
	}
	Reader->ReadObjectEnd(NextToken);

	LocalizedText = FLocalizedText(LocStringMap, LanguageSwitcher);
	return true;
}

template <typename DocumentReferenceType>
bool UTestData::ReadDocumentReferenceCollection
(
	const TSharedRef<IGameDataReader>& Reader,
	TArray<DocumentReferenceType>& Collection,
	const FString& SchemaIdOrName,
	TArray<FString>& GameDataPath,
	bool NextToken
)
{
	Collection.Empty();
	if (Reader->IsNull())
	{
		return true;
	}

	const bool IsByIdCollection = Reader->GetNotation() == EJsonNotation::ObjectStart;

	if (IsByIdCollection)
	{
		Reader->ReadObjectBegin();
	}
	else
	{
		Reader->ReadArrayBegin();
	}
	while (Reader->GetNotation() != EJsonNotation::ArrayEnd &&
			Reader->GetNotation() != EJsonNotation::ObjectEnd)
	{
		if (Reader->IsError())
		{
			UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
			return false;
		}
		if (Reader->IsNull())
		{
			Reader->ReadNext();
			continue;
		}

		DocumentReferenceType DocumentReference;
		if (!ReadDocumentReference(Reader, DocumentReference, SchemaIdOrName, GameDataPath))
		{
			UE_LOG(LogUTestData, Error, TEXT("Failed to read document reference. Path: %s."), *CombineGameDataPath(GameDataPath));
			return false;
		}
		Collection.Add(DocumentReference);
	}
	if (IsByIdCollection)
	{
		Reader->ReadObjectEnd(NextToken);
	}
	else
	{
		Reader->ReadArrayEnd(NextToken);
	}

	if (Reader->IsError())
	{
		UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
		return false;
	}

	return true;
}

bool UTestData::ReadDocumentReference
(
	const TSharedRef<IGameDataReader>& Reader,
	FGameDataDocumentReference& DocumentReference,
	const FString& SchemaIdOrName,
	TArray<FString>& GameDataPath,
	bool NextToken
)
{
	FString Id;
	Reader->ReadObjectBegin();
	while (Reader->GetNotation() != EJsonNotation::ObjectEnd)
	{
		if (Reader->IsError())
		{
			UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
			return false;
		}

		auto MemberName = Reader->ReadMember();
		if (MemberName == TEXT("Id"))
		{
			if (!Reader->ReadValue(Id))
			{
				UE_LOG(LogUTestData, Error, TEXT("Failed to read 'Id' value for document reference. Path: %s."), *CombineGameDataPath(GameDataPath));
				return false;
			}
			Reader->ReadNext();
		}
		else
		{
			Reader->SkipAny();
		}
	}

	Reader->ReadObjectEnd(NextToken);

	if (Id.IsEmpty())
	{
		UE_LOG(LogUTestData, Error, TEXT("Document reference 'Id' is null or empty. Path: %s."), *CombineGameDataPath(GameDataPath));
		return false;
	}

	DocumentReference.Id = Id;
	DocumentReference.SchemaIdOrName = SchemaIdOrName;
	DocumentReference.GameData = this;

	return true;
}

template <typename FormulaType>
bool UTestData::ReadFormula
(
		const TSharedRef<IGameDataReader>& Reader,
		FormulaType*& Formula,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken
)
{
	if (Reader->IsError())
	{
		UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
		return false;
	}

	TSharedPtr<FJsonObject> FormulaObject;
	if (!Reader->ReadObject(FormulaObject, NextToken) || FormulaObject == nullptr)
	{
		UE_LOG(LogUTestData, Error, TEXT("Failed to read JsonObject for Formula data type. Path: %s."), *CombineGameDataPath(GameDataPath));
		return false;
	}

	if (Reader->IsError())
	{
		UE_LOG(LogUTestData, Error, TEXT("File pasing failed due error '%s'. Path: %s."), *Reader->GetErrorMessage(), *CombineGameDataPath(GameDataPath));
		return false;
	}

	Formula = NewObject<FormulaType>(Outer);
	Formula->ExpressionTree.JsonObject = FormulaObject;

	return true;
}

FString UTestData::CombineGameDataPath(const TArray<FString>& GameDataPath)
{
	return FString::Join(GameDataPath, TEXT("/"));
}
TSharedPtr<FJsonObject> UTestData::MergeGameData(const TSharedPtr<FJsonObject>& GameDataDocument, const TSharedPtr<FJsonObject>& PatchDocument)
{
	const TSharedPtr<FJsonObject>* GameDataCollections;
	if (!GameDataDocument->TryGetObjectField(TEXT("Collections"), GameDataCollections)) {
		GameDataCollections = nullptr;
	}

	const TSharedPtr<FJsonObject>* PatchCollections;
	if (!PatchDocument->TryGetObjectField(TEXT("Collections"), PatchCollections)) {
		PatchCollections = nullptr;
	}

	auto MergedCollections = MakeShared<FJsonObject>();
	if (GameDataCollections != nullptr && GameDataCollections->IsValid() &&
		PatchCollections != nullptr && PatchCollections->IsValid())
	{
		auto& GameDataCollectionsMap = GameDataCollections->Get()->Values;
		auto& PatchCollectionsMap = PatchCollections->Get()->Values;

		TSet<FString> VisitedSchemas;
		auto SchemaNames = MergeKeys(GameDataCollectionsMap, PatchCollectionsMap);

		for (auto SchemaName : SchemaNames.Get())
		{
			if (VisitedSchemas.Contains(SchemaName))
			{
				continue;
			}
			if (SchemaName == TEXT("55a4f32faca22e191098f3d9") || SchemaName == TEXT("ProjectSettings"))
			{
				VisitedSchemas.Add(TEXT("55a4f32faca22e191098f3d9"));
				VisitedSchemas.Add(TEXT("ProjectSettings"));

				auto GameDataDocumentCollection = GameDataCollectionsMap.Find(TEXT("55a4f32faca22e191098f3d9"));
				if (GameDataDocumentCollection == nullptr)
				{
					GameDataDocumentCollection = GameDataCollectionsMap.Find(TEXT("ProjectSettings"));
				}
				auto PatchDocumentCollection = PatchCollectionsMap.Find(TEXT("55a4f32faca22e191098f3d9"));
				if (PatchDocumentCollection == nullptr)
				{
					PatchDocumentCollection = PatchCollectionsMap.Find(TEXT("ProjectSettings"));
				}

				if (GameDataDocumentCollection != nullptr && PatchDocumentCollection != nullptr)
				{
					auto MergedCollection = MergeDocumentCollection(GameDataDocumentCollection->ToSharedRef(), PatchDocumentCollection->ToSharedRef(), TEXT("UTestDataProjectSettings"), false);
					MergedCollections->SetField(TEXT("ProjectSettings"), MergedCollection);
				}
				else if (GameDataDocumentCollection != nullptr)
				{
					MergedCollections->SetField(TEXT("ProjectSettings"), *GameDataDocumentCollection);
				}
				else if (PatchDocumentCollection != nullptr)
				{
					MergedCollections->SetField(TEXT("ProjectSettings"), *PatchDocumentCollection);
				}
			}
			else
			if (SchemaName == TEXT("592fc86c983a36266c0912a0") || SchemaName == TEXT("TestEntity"))
			{
				VisitedSchemas.Add(TEXT("592fc86c983a36266c0912a0"));
				VisitedSchemas.Add(TEXT("TestEntity"));

				auto GameDataDocumentCollection = GameDataCollectionsMap.Find(TEXT("592fc86c983a36266c0912a0"));
				if (GameDataDocumentCollection == nullptr)
				{
					GameDataDocumentCollection = GameDataCollectionsMap.Find(TEXT("TestEntity"));
				}
				auto PatchDocumentCollection = PatchCollectionsMap.Find(TEXT("592fc86c983a36266c0912a0"));
				if (PatchDocumentCollection == nullptr)
				{
					PatchDocumentCollection = PatchCollectionsMap.Find(TEXT("TestEntity"));
				}

				if (GameDataDocumentCollection != nullptr && PatchDocumentCollection != nullptr)
				{
					auto MergedCollection = MergeDocumentCollection(GameDataDocumentCollection->ToSharedRef(), PatchDocumentCollection->ToSharedRef(), TEXT("UTestEntity"), false);
					MergedCollections->SetField(TEXT("TestEntity"), MergedCollection);
				}
				else if (GameDataDocumentCollection != nullptr)
				{
					MergedCollections->SetField(TEXT("TestEntity"), *GameDataDocumentCollection);
				}
				else if (PatchDocumentCollection != nullptr)
				{
					MergedCollections->SetField(TEXT("TestEntity"), *PatchDocumentCollection);
				}
			}
			else
			if (SchemaName == TEXT("592fc894983a36266c0912a4") || SchemaName == TEXT("RecursiveEntity"))
			{
				VisitedSchemas.Add(TEXT("592fc894983a36266c0912a4"));
				VisitedSchemas.Add(TEXT("RecursiveEntity"));

				auto GameDataDocumentCollection = GameDataCollectionsMap.Find(TEXT("592fc894983a36266c0912a4"));
				if (GameDataDocumentCollection == nullptr)
				{
					GameDataDocumentCollection = GameDataCollectionsMap.Find(TEXT("RecursiveEntity"));
				}
				auto PatchDocumentCollection = PatchCollectionsMap.Find(TEXT("592fc894983a36266c0912a4"));
				if (PatchDocumentCollection == nullptr)
				{
					PatchDocumentCollection = PatchCollectionsMap.Find(TEXT("RecursiveEntity"));
				}

				if (GameDataDocumentCollection != nullptr && PatchDocumentCollection != nullptr)
				{
					auto MergedCollection = MergeDocumentCollection(GameDataDocumentCollection->ToSharedRef(), PatchDocumentCollection->ToSharedRef(), TEXT("URecursiveEntity"), false);
					MergedCollections->SetField(TEXT("RecursiveEntity"), MergedCollection);
				}
				else if (GameDataDocumentCollection != nullptr)
				{
					MergedCollections->SetField(TEXT("RecursiveEntity"), *GameDataDocumentCollection);
				}
				else if (PatchDocumentCollection != nullptr)
				{
					MergedCollections->SetField(TEXT("RecursiveEntity"), *PatchDocumentCollection);
				}
			}
			else
			if (SchemaName == TEXT("592fdb43983a3619c016b696") || SchemaName == TEXT("NumberTestEntity"))
			{
				VisitedSchemas.Add(TEXT("592fdb43983a3619c016b696"));
				VisitedSchemas.Add(TEXT("NumberTestEntity"));

				auto GameDataDocumentCollection = GameDataCollectionsMap.Find(TEXT("592fdb43983a3619c016b696"));
				if (GameDataDocumentCollection == nullptr)
				{
					GameDataDocumentCollection = GameDataCollectionsMap.Find(TEXT("NumberTestEntity"));
				}
				auto PatchDocumentCollection = PatchCollectionsMap.Find(TEXT("592fdb43983a3619c016b696"));
				if (PatchDocumentCollection == nullptr)
				{
					PatchDocumentCollection = PatchCollectionsMap.Find(TEXT("NumberTestEntity"));
				}

				if (GameDataDocumentCollection != nullptr && PatchDocumentCollection != nullptr)
				{
					auto MergedCollection = MergeDocumentCollection(GameDataDocumentCollection->ToSharedRef(), PatchDocumentCollection->ToSharedRef(), TEXT("UNumberTestEntity"), false);
					MergedCollections->SetField(TEXT("NumberTestEntity"), MergedCollection);
				}
				else if (GameDataDocumentCollection != nullptr)
				{
					MergedCollections->SetField(TEXT("NumberTestEntity"), *GameDataDocumentCollection);
				}
				else if (PatchDocumentCollection != nullptr)
				{
					MergedCollections->SetField(TEXT("NumberTestEntity"), *PatchDocumentCollection);
				}
			}
			else
			if (SchemaName == TEXT("65d3565e27363a98010000ec") || SchemaName == TEXT("UniqueAttributeEntity"))
			{
				VisitedSchemas.Add(TEXT("65d3565e27363a98010000ec"));
				VisitedSchemas.Add(TEXT("UniqueAttributeEntity"));

				auto GameDataDocumentCollection = GameDataCollectionsMap.Find(TEXT("65d3565e27363a98010000ec"));
				if (GameDataDocumentCollection == nullptr)
				{
					GameDataDocumentCollection = GameDataCollectionsMap.Find(TEXT("UniqueAttributeEntity"));
				}
				auto PatchDocumentCollection = PatchCollectionsMap.Find(TEXT("65d3565e27363a98010000ec"));
				if (PatchDocumentCollection == nullptr)
				{
					PatchDocumentCollection = PatchCollectionsMap.Find(TEXT("UniqueAttributeEntity"));
				}

				if (GameDataDocumentCollection != nullptr && PatchDocumentCollection != nullptr)
				{
					auto MergedCollection = MergeDocumentCollection(GameDataDocumentCollection->ToSharedRef(), PatchDocumentCollection->ToSharedRef(), TEXT("UUniqueAttributeEntity"), false);
					MergedCollections->SetField(TEXT("UniqueAttributeEntity"), MergedCollection);
				}
				else if (GameDataDocumentCollection != nullptr)
				{
					MergedCollections->SetField(TEXT("UniqueAttributeEntity"), *GameDataDocumentCollection);
				}
				else if (PatchDocumentCollection != nullptr)
				{
					MergedCollections->SetField(TEXT("UniqueAttributeEntity"), *PatchDocumentCollection);
				}
			}
			else
			{
				/* ignore schema */
			}
		}
	}
	else if (GameDataCollections != nullptr && GameDataCollections->IsValid())
	{
		MergedCollections = GameDataCollections->ToSharedRef();
	}
	else if (PatchCollections != nullptr && PatchCollections->IsValid())
	{
		MergedCollections = PatchCollections->ToSharedRef();
	}

	int MergedChangeNumber;
	if (GameDataDocument->HasTypedField<EJson::Number>(TEXT("ChangeNumber")))
	{
		GameDataDocument->GetField<EJson::Number>(TEXT("ChangeNumber"))->TryGetNumber(MergedChangeNumber);
	}
	if (PatchDocument->HasTypedField<EJson::Number>(TEXT("ChangeNumber")))
	{
		PatchDocument->GetField<EJson::Number>(TEXT("ChangeNumber"))->TryGetNumber(MergedChangeNumber);
	}

	FString MergedRevisionHash;
	if (GameDataDocument->HasTypedField<EJson::String>(TEXT("RevisionHash")))
	{
		GameDataDocument->GetField<EJson::String>(TEXT("RevisionHash"))->TryGetString(MergedRevisionHash);
	}
	if (PatchDocument->HasTypedField<EJson::String>(TEXT("RevisionHash")))
	{
		PatchDocument->GetField<EJson::String>(TEXT("RevisionHash"))->TryGetString(MergedRevisionHash);
	}

	auto MergedGameData = MakeShared<FJsonObject>();
	MergedGameData->SetField(TEXT("ChangeNumber"), MakeShared<FJsonValueNumber>(MergedChangeNumber));
	MergedGameData->SetField(TEXT("RevisionHash"), MakeShared<FJsonValueString>(MergedRevisionHash));
	MergedGameData->SetField(TEXT("Collections"), MakeShared<FJsonValueObject>(MergedCollections));
	return MergedGameData;
}

TSharedPtr<FJsonValue> UTestData::MergeDocumentCollection(TSharedRef<FJsonValue> OriginalCollection, TSharedRef<FJsonValue> ModifiedCollection, const FString TypeName, bool PurgeRest)
{
	struct ToIdMapper
	{
		static TSharedPtr<FJsonObject> ToDocumentById(TSharedRef<FJsonValue> Collection)
		{
			TSharedPtr<FJsonObject>* CollectionByIdPtr;
			TArray<TSharedPtr<FJsonValue>>* CollectionPtr;
			if (Collection->TryGetObject(CollectionByIdPtr) && CollectionByIdPtr != nullptr && CollectionByIdPtr->IsValid())
			{
				return *CollectionByIdPtr;
			}
			else if (Collection->TryGetArray(CollectionPtr) && CollectionPtr != nullptr)
			{
				auto CollectionById = MakeShared<FJsonObject>();
				for (auto DocumentOrNullPtr : *CollectionPtr)
				{
					TSharedPtr<FJsonObject>* DocumentObjectPtr;
					if (DocumentOrNullPtr->TryGetObject(DocumentObjectPtr) && DocumentObjectPtr->IsValid())
					{
						auto Document = DocumentObjectPtr->ToSharedRef();
						auto IdValue = Document->TryGetField(TEXT("Id"));
						double IdValueDouble;
						FString IdValueString;
						bool IdValueBool;
						if (IdValue != nullptr && IdValue->TryGetNumber(IdValueDouble))
						{
							CollectionById->SetObjectField(FString::Format(TEXT("{0}"), {IdValueDouble}), Document);
						}
						else if (IdValue != nullptr && IdValue->TryGetString(IdValueString))
						{
							CollectionById->SetObjectField(IdValueString, Document);
						}
						else if (IdValue != nullptr && IdValue->TryGetBool(IdValueBool))
						{
							CollectionById->SetObjectField(IdValueBool ? TEXT("True") : TEXT("False"), Document);
						}
					}
				}
				return CollectionById;
			}
			else
			{
				return MakeShared<FJsonObject>();
			}
		}
	};

	auto OriginalCollectionById = ToIdMapper::ToDocumentById(OriginalCollection);
	auto ModifiedCollectionById = ToIdMapper::ToDocumentById(ModifiedCollection);
	auto MergedCollectionById = MakeShared<FJsonObject>();
	auto DocumentIds = PurgeRest ? MergeKeys(ModifiedCollectionById->Values, TMap<FString, TSharedPtr<FJsonValue>>()) : MergeKeys(OriginalCollectionById->Values, ModifiedCollectionById->Values);

	for (auto DocumentId : DocumentIds.Get())
	{
		TSharedPtr<FJsonValue> OriginalDocumentObjectPtr = OriginalCollectionById->TryGetField(DocumentId);
		auto OriginalDocumentExists = OriginalDocumentObjectPtr.IsValid();

		TSharedPtr<FJsonValue> ModifiedDocumentObjectPtr = ModifiedCollectionById->TryGetField(DocumentId);
		auto ModifiedDocumentExists = ModifiedDocumentObjectPtr.IsValid();

		TSharedPtr<FJsonValue> MergedDocument = nullptr;
		if (OriginalDocumentExists && !ModifiedDocumentExists)
		{
			// unchanged
			MergedDocument = OriginalDocumentObjectPtr;
		}
		else if (OriginalDocumentExists && OriginalCollectionById->HasTypedField<EJson::Null>(DocumentId))
		{
			// keep deleted documents as deleted
			MergedDocument = nullptr;
		}
		else if (!OriginalDocumentExists && ModifiedDocumentExists)
		{
			// modified
			MergedDocument = ModifiedDocumentObjectPtr;
		}
		else if (OriginalDocumentExists && OriginalCollectionById->HasTypedField<EJson::Object>(DocumentId) &&
			ModifiedDocumentExists && ModifiedCollectionById->HasTypedField<EJson::Object>(DocumentId))
		{
			// merged
			MergedDocument = MergeDocument(OriginalDocumentObjectPtr.ToSharedRef(), ModifiedDocumentObjectPtr.ToSharedRef(), TypeName);
		}
		else
		{
			// modified
			MergedDocument = ModifiedDocumentObjectPtr;
		}


		if (MergedDocument)
		{
			MergedCollectionById->SetField(DocumentId, MergedDocument);
		}
		else
		{
			MergedCollectionById->SetField(DocumentId, MakeShared<FJsonValueNull>());
		}
	}

	return MakeShared<FJsonValueObject>(MergedCollectionById);
}

TSharedPtr<FJsonValue> UTestData::MergeDocument(TSharedRef<FJsonValue> OriginalDocument, TSharedRef<FJsonValue> ModifiedDocument, const FString& TypeName)
{
	TSharedPtr<FJsonObject>* OriginalDocumentObjectPtr;
	if (!OriginalDocument->TryGetObject(OriginalDocumentObjectPtr))
	{
		OriginalDocumentObjectPtr = nullptr;
	}

	TSharedPtr<FJsonObject>* ModifiedDocumentObjectPtr;
	if (!ModifiedDocument->TryGetObject(ModifiedDocumentObjectPtr))
	{
		ModifiedDocumentObjectPtr = nullptr;
	}

	if (OriginalDocumentObjectPtr == nullptr || !OriginalDocumentObjectPtr->IsValid() ||
		ModifiedDocumentObjectPtr == nullptr || !ModifiedDocumentObjectPtr->IsValid())
	{
		return nullptr;
	}

	auto ModifiedDocumentObjectRef = ModifiedDocumentObjectPtr->ToSharedRef();
	auto OriginalDocumentObjectRef = OriginalDocumentObjectPtr->ToSharedRef();
	auto MergedDocument = MakeShared<FJsonObject>();
	if (TypeName == TEXT("UTestDataProjectSettings"))
	{
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Id"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Name"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("PrimaryLanguage"));
		MergePropertyLanguagesValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Languages"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Copyright"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Version"));
	}
	else
	if (TypeName == TEXT("UTestEntity"))
	{
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Id"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("TextField"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("LocalizedTextField"), OptionalMergeValueFunc([this](TSharedRef<FJsonValue> OriginalValue, TSharedRef<FJsonValue> ModifiedValue) { return MergeLocalizedText(OriginalValue, ModifiedValue); }));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("LogicalField"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("TimeField"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("DateField"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("NumberField"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("NumberFieldX64"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("IntegerField"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("IntegerFieldX64"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("PickListField"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("MultiPickListField"));
		MergePropertyDocumentValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("DocumentField"), OptionalMergeValueFunc([this](TSharedRef<FJsonValue> OriginalValue, TSharedRef<FJsonValue> ModifiedValue) { return MergeDocument(OriginalValue, ModifiedValue, TEXT("UTestEntity")); }));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("ListOfDocumentsField"), OptionalMergeValueFunc([this](TSharedRef<FJsonValue> OriginalValue, TSharedRef<FJsonValue> ModifiedValue) { return MergeDocumentCollection(OriginalValue, ModifiedValue, TEXT("UTestEntity"), true); }));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("ReferenceField"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("ListOfReferencesField"), OptionalMergeValueFunc([this](TSharedRef<FJsonValue> OriginalValue, TSharedRef<FJsonValue> ModifiedValue) { return MergeDocumentCollection(OriginalValue, ModifiedValue, TEXT("UTestEntity"), true); }));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("FormulaField"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("IsPublished"));
	}
	else
	if (TypeName == TEXT("URecursiveEntity"))
	{
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Id"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Title"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Children"), OptionalMergeValueFunc([this](TSharedRef<FJsonValue> OriginalValue, TSharedRef<FJsonValue> ModifiedValue) { return MergeDocumentCollection(OriginalValue, ModifiedValue, TEXT("URecursiveEntity"), true); }));
	}
	else
	if (TypeName == TEXT("UNumberTestEntity"))
	{
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Id"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Number32Bit"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Number64Bit"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Integer8Bit"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Integer16Bit"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Integer32Bit"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Integer64Bit"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("PickList8Bit"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("PickList16Bit"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("PickList32Bit"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("PickList64Bit"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("MultiPickList8Bit"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("MultiPickList16Bit"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("MultiPickList32Bit"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("MultiPickList64Bit"));
	}
	else
	if (TypeName == TEXT("UUniqueAttributeEntity"))
	{
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("Id"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("snake_case_key"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("camelCaseKey"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("DromedaryCaseKey"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("TextKey"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("NonRequiredKey"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("NumberKey"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("IntegerKey"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("PickListKey"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("MultiPickListKey"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("TimeSpanKey"));
		MergePropertyValue(MergedDocument, OriginalDocumentObjectRef, ModifiedDocumentObjectRef, TEXT("DateTimeKey"));
	}
	else
	{
		/* ignore type */
	}

	return MakeShared<FJsonValueObject>(MergedDocument);
}


void UTestData::MergePropertyDocumentValue(TSharedRef<FJsonObject> MergedDocument, TSharedRef<FJsonObject> OriginalDocument, TSharedRef<FJsonObject> ModifiedDocument, const FString PropertyName, OptionalMergeValueFunc MergeFn)
{
	const TSharedPtr<FJsonObject>* ModifiedDocumentObjectPtr;
	if (ModifiedDocument->TryGetObjectField(PropertyName, ModifiedDocumentObjectPtr) &&
		ModifiedDocumentObjectPtr != nullptr && ModifiedDocumentObjectPtr->IsValid() &&
		!ModifiedDocumentObjectPtr->Get()->HasField(TEXT("Id")) &&
		OriginalDocument->HasTypedField<EJson::Null>(PropertyName))
	{
		// unable to merge partial data into missing document
		MergedDocument->SetField(PropertyName, MakeShared<FJsonValueNull>());
		return;
	}

	MergePropertyValue(MergedDocument, OriginalDocument, ModifiedDocument, PropertyName, MergeFn);
}

void UTestData::MergePropertyLanguagesValue(TSharedRef<FJsonObject> MergedDocument, TSharedRef<FJsonObject> OriginalDocument, TSharedRef<FJsonObject> ModifiedDocument, const FString PropertyName)
{
	auto OriginalValue = OriginalDocument->TryGetField(PropertyName);
	auto OriginalValueExists = OriginalValue.IsValid();

	auto ModifiedValue = ModifiedDocument->TryGetField(PropertyName);
	auto ModifiedValueExists = ModifiedValue.IsValid();

	if (!OriginalValueExists && !ModifiedValueExists)
	{
		return;
	}

	auto OriginalLanguageListStr = OriginalValueExists && OriginalValue->Type == EJson::String ? OriginalValue->AsString() : FString();
	auto ModifiedLanguageListStr = ModifiedValueExists && ModifiedValue->Type == EJson::String ? ModifiedValue->AsString() : FString();
	auto OriginalLanguageList = TArray<FString>();
	auto ModifiedLanguageList = TArray<FString>();

	ParseLanguageList(OriginalLanguageListStr, OriginalLanguageList);
	ParseLanguageList(ModifiedLanguageListStr, ModifiedLanguageList);

	for (const auto LanguageId : ModifiedLanguageList)
	{
		if (OriginalLanguageList.Contains(LanguageId))
		{
			continue;
		}
		OriginalLanguageList.Add(LanguageId);
	}

	MergedDocument->SetStringField(PropertyName, FString::Join(OriginalLanguageList, TEXT(";")));
}

void UTestData::MergePropertyValue(TSharedRef<FJsonObject> MergedDocument, TSharedRef<FJsonObject> OriginalDocument, TSharedRef<FJsonObject> ModifiedDocument, const FString PropertyName, OptionalMergeValueFunc MergeFn)
{
	auto OriginalValue = OriginalDocument->TryGetField(PropertyName);
	auto OriginalValueExists = OriginalValue.IsValid();

	auto ModifiedValue = ModifiedDocument->TryGetField(PropertyName);
	auto ModifiedValueExists = ModifiedValue.IsValid();

	if (!OriginalValueExists && !ModifiedValueExists)
	{
		return;
	}

	TSharedPtr<FJsonValue> MergedValue = nullptr;
	if (OriginalValueExists && !ModifiedValueExists)
	{
		// unchanged
		MergedValue = OriginalValue;
	}
	else if (!OriginalValueExists && ModifiedValueExists)
	{
		// modified
		MergedValue = ModifiedValue;
	}
	else if (OriginalValue != nullptr && ModifiedValue != nullptr)
	{
		// modified
		if (MergeFn.IsSet())
		{
			MergedValue = MergeFn.GetValue()(OriginalValue.ToSharedRef(), ModifiedValue.ToSharedRef());
		}
		else
		{
			MergedValue = ModifiedValue;
		}
	}
	else
	{
		// modified
		MergedValue = ModifiedValue;
	}


	if (MergedValue != nullptr)
	{
		MergedDocument->SetField(PropertyName, MergedValue);
	}
	else
	{
		MergedDocument->SetField(PropertyName, MakeShared<FJsonValueNull>());
	}
}

TSharedRef<FJsonValue> UTestData::MergeLocalizedText(TSharedRef<FJsonValue> OriginalLocalizedText, TSharedRef<FJsonValue> ModifiedLocalizedText)
{
	struct TextComparer
	{
		static bool IsSame(TSharedRef<FJsonObject> Left, TSharedRef<FJsonObject> Right)
		{
			TArray<FString> Keys;
			for(int i = 0; i < 2; i++)
			{
				if (i == 0)
				{
					Left->Values.GetKeys(Keys);
				}
				else
				{
					Right->Values.GetKeys(Keys);
				}

				for (auto LanguageId : Keys)
				{
					if(LanguageId == TEXT("notes"))
					{
						continue;;
					}

					auto LeftValue = Left->TryGetField(LanguageId);
					auto RightValue = Right->TryGetField(LanguageId);
					FString LeftText, RightText;

					if (LeftValue == nullptr || RightValue == nullptr || LeftValue->Type != RightValue->Type)
					{
						return false;
					}

					if (LeftValue->TryGetString(LeftText) &&
						RightValue->TryGetString(RightText) &&
						LeftText != RightText)
					{
						return false;
					}

				}
			}

			return true;
		}
	};

	TSharedPtr<FJsonObject>* OriginalLocalizedTextPtr;
	if (!OriginalLocalizedText->TryGetObject(OriginalLocalizedTextPtr))
	{
		OriginalLocalizedTextPtr = nullptr;
	}

	TSharedPtr<FJsonObject>* ModifiedLocalizedTextPtr;
	if (!ModifiedLocalizedText->TryGetObject(ModifiedLocalizedTextPtr))
	{
		ModifiedLocalizedTextPtr = nullptr;
	}

	if (OriginalLocalizedTextPtr == nullptr || !OriginalLocalizedTextPtr->IsValid())
	{
		return ModifiedLocalizedTextPtr != nullptr && ModifiedLocalizedTextPtr->IsValid() ?
			MakeShared<FJsonValueObject>(*ModifiedLocalizedTextPtr) : static_cast<TSharedRef<FJsonValue>>(MakeShared<FJsonValueNull>());
	}
	else if (ModifiedLocalizedTextPtr == nullptr || !ModifiedLocalizedTextPtr->IsValid())
	{
		return OriginalLocalizedTextPtr != nullptr && OriginalLocalizedTextPtr->IsValid() ?
			MakeShared<FJsonValueObject>(*OriginalLocalizedTextPtr) : static_cast<TSharedRef<FJsonValue>>(MakeShared<FJsonValueNull>());
	}
	else if (TextComparer::IsSame(OriginalLocalizedTextPtr->ToSharedRef(), ModifiedLocalizedTextPtr->ToSharedRef()))
	{
		return MakeShared<FJsonValueObject>(*OriginalLocalizedTextPtr);
	}

	auto& OriginalLocalizedTextMap = OriginalLocalizedTextPtr->Get()->Values;
	auto& ModifiedLocalizedTextMap = ModifiedLocalizedTextPtr->Get()->Values;
	auto LanguageIds = MergeKeys(OriginalLocalizedTextMap, ModifiedLocalizedTextMap);
	auto MergedLocalizedText = MakeShared<FJsonObject>();
	for (auto LanguageId : LanguageIds.Get())
	{
		auto OriginalText = OriginalLocalizedTextMap.Find(LanguageId);
		auto ModifiedText = ModifiedLocalizedTextMap.Find(LanguageId);

		if (ModifiedText != nullptr && ModifiedText->IsValid())
		{
			MergedLocalizedText->SetField(LanguageId, *ModifiedText);
		}
		else if (OriginalText != nullptr && OriginalText->IsValid())
		{
			MergedLocalizedText->SetField(LanguageId, *OriginalText);
		}
	}

	return MakeShared<FJsonValueObject>(MergedLocalizedText);
}

TSharedRef<TArray<FString>> UTestData::MergeKeys(const TMap<FString, TSharedPtr<FJsonValue>>& Collection1, const TMap<FString, TSharedPtr<FJsonValue>>& Collection2)
{
	TArray<FString> Keys;
	Collection1.GetKeys(Keys);

	auto MergedKeys = MakeShared<TArray<FString>>();
	for (auto Key : Keys)
	{
		MergedKeys->Push(Key);
	}

	Collection2.GetKeys(Keys);
	for (auto Key : Keys)
	{
		if (MergedKeys->Contains(Key))
		{
			continue; // skip duplicates
		}
		MergedKeys->Push(Key);
	}
	return MergedKeys;
}
void UTestData::ApplyVisitor(FVisitor& Visitor) const
{
	for (const auto Document : GetRootDocuments())
	{
		Visitor.Visit(Document);
	}
}

void UTestData::ResolveAllReferences()
{
	auto DereferencingVisitor = UTestData::FDereferencingVisitor();
	ApplyVisitor(DereferencingVisitor);
}

void UTestData::FindAllDocuments()
{
	auto FindingVisitor = UTestData::FFindingVisitor();
	ApplyVisitor(FindingVisitor);
		ToMapById(this->AllProjectSettingsList, FindingVisitor.ProjectSettings);
		ToMapById(this->AllTestEntities, FindingVisitor.TestEntity);
		ToMapById(this->AllRecursiveEntities, FindingVisitor.RecursiveEntity);
		ToMapById(this->AllNumberTestEntities, FindingVisitor.NumberTestEntity);
		ToMapById(this->AllUniqueAttributeEntities, FindingVisitor.UniqueAttributeEntity);
}

void UTestData::FVisitor::Visit(UGameDataDocument* Document)
{
	if (Document == nullptr)
	{
		return;
	}
	else if ((Document->GetClass() == UTestDataProjectSettings::StaticClass()))
	{
		Visit(static_cast<UTestDataProjectSettings&>(*Document));
	}
	else if ((Document->GetClass() == UTestEntity::StaticClass()))
	{
		Visit(static_cast<UTestEntity&>(*Document));
	}
	else if ((Document->GetClass() == URecursiveEntity::StaticClass()))
	{
		Visit(static_cast<URecursiveEntity&>(*Document));
	}
	else if ((Document->GetClass() == UNumberTestEntity::StaticClass()))
	{
		Visit(static_cast<UNumberTestEntity&>(*Document));
	}
	else if ((Document->GetClass() == UUniqueAttributeEntity::StaticClass()))
	{
		Visit(static_cast<UUniqueAttributeEntity&>(*Document));
	}
}
void UTestData::FVisitor::Visit(UTestDataProjectSettings& Document)
{
}
void UTestData::FVisitor::Visit(UTestEntity& Document)
{
	if (Document.DocumentField)
	{
		Visit (static_cast<UGameDataDocument*>(Document.DocumentField));
	}
	for (const auto SubDocumentById : Document.ListOfDocumentsField)
	{
		if (SubDocumentById.Value == nullptr) { continue; }
		Visit(static_cast<UGameDataDocument*>(SubDocumentById.Value));
	}
}
void UTestData::FVisitor::Visit(URecursiveEntity& Document)
{
	for (const auto SubDocumentById : Document.Children)
	{
		if (SubDocumentById.Value == nullptr) { continue; }
		Visit(static_cast<UGameDataDocument*>(SubDocumentById.Value));
	}
}
void UTestData::FVisitor::Visit(UNumberTestEntity& Document)
{
}
void UTestData::FVisitor::Visit(UUniqueAttributeEntity& Document)
{
}
void UTestData::FFindingVisitor::Visit(UTestDataProjectSettings& Document)
{
	if (this->ProjectSettings.Num() == 0)
	{
		this->ProjectSettings.Reserve(6);
	}
	this->ProjectSettings.Add(&Document);

	FVisitor::Visit(Document);
}
void UTestData::FFindingVisitor::Visit(UTestEntity& Document)
{
	if (this->TestEntity.Num() == 0)
	{
		this->TestEntity.Reserve(8);
	}
	this->TestEntity.Add(&Document);

	FVisitor::Visit(Document);
}
void UTestData::FFindingVisitor::Visit(URecursiveEntity& Document)
{
	if (this->RecursiveEntity.Num() == 0)
	{
		this->RecursiveEntity.Reserve(11);
	}
	this->RecursiveEntity.Add(&Document);

	FVisitor::Visit(Document);
}
void UTestData::FFindingVisitor::Visit(UNumberTestEntity& Document)
{
	if (this->NumberTestEntity.Num() == 0)
	{
		this->NumberTestEntity.Reserve(7);
	}
	this->NumberTestEntity.Add(&Document);

	FVisitor::Visit(Document);
}
void UTestData::FFindingVisitor::Visit(UUniqueAttributeEntity& Document)
{
	if (this->UniqueAttributeEntity.Num() == 0)
	{
		this->UniqueAttributeEntity.Reserve(6);
	}
	this->UniqueAttributeEntity.Add(&Document);

	FVisitor::Visit(Document);
}
void UTestData::FDereferencingVisitor::Visit(UTestDataProjectSettings& Document)
{
	FVisitor::Visit(Document);
}
void UTestData::FDereferencingVisitor::Visit(UTestEntity& Document)
{
	if (Document.ReferenceFieldRaw.IsValid())
	{ auto _ = Document.ReferenceFieldRaw.GetReferencedDocument(); }
	{ auto _ = Document.GetListOfReferencesField(); }
	FVisitor::Visit(Document);
}
void UTestData::FDereferencingVisitor::Visit(URecursiveEntity& Document)
{
	FVisitor::Visit(Document);
}
void UTestData::FDereferencingVisitor::Visit(UNumberTestEntity& Document)
{
	FVisitor::Visit(Document);
}
void UTestData::FDereferencingVisitor::Visit(UUniqueAttributeEntity& Document)
{
	FVisitor::Visit(Document);
}
