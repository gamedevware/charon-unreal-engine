
#pragma once
//
// The source code was generated by the Charon, GameDevWare, 2024
// License: MIT
//
//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// ReSharper disable All

#include <type_traits>

#include "GameData/UGameDataDocument.h"
#include "GameData/FLocalizedText.h"
#include "GameData/ULanguageSwitcher.h"
#include "GameData/EGameDataFormat.h"
#include "GameData/UGameDataBase.h"
#include "GameData/FGameDataLoadOptions.h"
#include "GameData/FGameDataDocumentIdConvert.h"
#include "GameData/Formatters/FGameDataReaderFactory.h"
#include "GameData/Formatters/IGameDataReader.h"

#include "Serialization/JsonReader.h"
#include "Serialization/JsonTypes.h"
#include "Serialization/Archive.h"
#include "UTestDataProjectSettings.h"
#include "UTestEntity.h"
#include "URecursiveEntity.h"
#include "UNumberTestEntity.h"
#include "UUniqueAttributeEntity.h"
#include "ETestEntityPickListField.h"
#include "ETestEntityMultiPickListField.h"
#include "ENumberTestEntityPickList8Bit.h"
#include "ENumberTestEntityPickList16Bit.h"
#include "ENumberTestEntityPickList32Bit.h"
#include "ENumberTestEntityPickList64Bit.h"
#include "ENumberTestEntityMultiPickList8Bit.h"
#include "ENumberTestEntityMultiPickList16Bit.h"
#include "ENumberTestEntityMultiPickList32Bit.h"
#include "ENumberTestEntityMultiPickList64Bit.h"
#include "EUniqueAttributeEntityPickListKey.h"
#include "EUniqueAttributeEntityMultiPickListKey.h"
#include "ETestEntityId.h"
#include "ERecursiveEntityId.h"
#include "EUniqueAttributeEntityId.h"
#include "EUniqueAttributeEntitySnakeCaseKey.h"
#include "EUniqueAttributeEntityCamelCaseKey.h"
#include "EUniqueAttributeEntityDromedaryCaseKey.h"
#include "EUniqueAttributeEntityTextKey.h"
#include "EUniqueAttributeEntityNumberKey.h"
#include "EUniqueAttributeEntityIntegerKey.h"
#include "EUniqueAttributeEntityTimeSpanKey.h"
#include "EUniqueAttributeEntityDateTimeKey.h"
#include "UTestEntityFormulaFieldFormula.h"
#include "UTestData.generated.h"

DECLARE_LOG_CATEGORY_EXTERN(LogUTestData, Log, All);

/**
  * Main class used to access game data.
  */
UCLASS(BlueprintType)
class TESTDATA_API UTestData : public UGameDataBase
{
	GENERATED_BODY()

public:
	inline static const FString GeneratorName = TEXT("Charon");
	inline static const FString GeneratorVersion = TEXT("2025.1.1.0");

private:
	UPROPERTY()
	TMap<FString,UTestDataProjectSettings*> AllProjectSettingsList;
	UPROPERTY()
	TMap<FString,UTestDataProjectSettings*> ProjectSettingsList;

	TSharedPtr<TArray<UGameDataDocument*>> RootDocuments;
	TSharedPtr<TArray<UGameDataDocument*>> AllDocuments;

	UPROPERTY()
	ULanguageSwitcher* LanguageSwitcher;

public:
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	int32 ChangeNumber;

	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	FString RevisionHash;

	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	FString GameDataVersion;

	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TArray<FString> SupportedLanguages;

	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	UTestDataProjectSettings* ProjectSettings;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,UTestEntity*> AllTestEntities;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,UTestEntity*> TestEntities;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,URecursiveEntity*> AllRecursiveEntities;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,URecursiveEntity*> RecursiveEntities;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<int32,UNumberTestEntity*> AllNumberTestEntities;
	UPROPERTY(BlueprintReadOnly)
	TMap<int32,UNumberTestEntity*> NumberTestEntities;
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
	TMap<FString,UUniqueAttributeEntity*> AllUniqueAttributeEntities;
	UPROPERTY(BlueprintReadOnly)
	TMap<FString,UUniqueAttributeEntity*> UniqueAttributeEntities;

	virtual bool TryLoad(FArchive* const GameDataStream, EGameDataFormat Format) override;
	bool TryLoad(FArchive* const GameDataStream, FGameDataLoadOptions Options);

	const TArray<UGameDataDocument*>& GetAllDocuments() const;
	const TArray<UGameDataDocument*>& GetRootDocuments() const;

	virtual UGameDataDocument* FindGameDataDocumentById(const FString& SchemaNameOrId, const FString& DocumentId) override;
	virtual UClass* FindDocumentSchemaClass(const FString& SchemaNameOrId) override;
	virtual void GetDocumentIds(const FString& SchemaNameOrId, TArray<FString>& AllIds) override;
	virtual void GetDocumentSchemaNames(TArray<FString>& AllSchemaNames) override;

	UFUNCTION(BlueprintCallable)
	void SetLanguage(
		FString LanguageId,
		FString FallbackLanguageId = TEXT("ru-RU"),
		ELocalizedTextFallbackOption FallbackOption = ELocalizedTextFallbackOption::OnNull)
	{
		if (LanguageSwitcher == nullptr)
		{
			return;
		}

		LanguageSwitcher->CurrentLanguageId = LanguageId;
		LanguageSwitcher->FallbackLanguageId = FallbackLanguageId;
		LanguageSwitcher->FallbackOption = FallbackOption;
	}

private:
	void Empty();
	void UpdateProjectSettings();
	void UpdateSettings();
	void ParseLanguageList(const FString& InLanguages, TArray<FString>& OutLanguageList);

	template <typename IdType, typename DocumentType>
	DocumentType* GetOne(const TMap<IdType, DocumentType*>& Documents) const;
	template <typename IdType, typename DocumentType>
	void ToMapById(TMap<IdType, DocumentType*>& DocumentsById, TArray<DocumentType*>& Documents);
	TSharedRef<IGameDataReader> CreateReader(FArchive* const GameDataStream, const FGameDataLoadOptions& Options);

	bool ReadGameData(const TSharedRef<IGameDataReader>& Reader);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UTestDataProjectSettings*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UTestEntity*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		URecursiveEntity*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UNumberTestEntity*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadDocument
	(
		const TSharedRef<IGameDataReader>& Reader,
		UUniqueAttributeEntity*& Document,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	template <typename IdType, typename DocumentType>
	bool ReadDocumentCollection
	(
		const TSharedRef<IGameDataReader>& Reader,
		TMap<IdType,DocumentType*>& Collection,
		int32 Capacity,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);
	bool ReadLocalizedText
	(
		const TSharedRef<IGameDataReader>& Reader,
		FLocalizedText& LocalizedText,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);

	template <typename DocumentReferenceType>
	bool ReadDocumentReferenceCollection
	(
		const TSharedRef<IGameDataReader>& Reader,
		TArray<DocumentReferenceType>& Collection,
		const FString& SchemaIdOrName,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);

	bool ReadDocumentReference
	(
		const TSharedRef<IGameDataReader>& Reader,
		FGameDataDocumentReference& DocumentReference,
		const FString& SchemaIdOrName,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);

	template <typename FormulaType>
	bool ReadFormula
	(
		const TSharedRef<IGameDataReader>& Reader,
		FormulaType*& Formula,
		UObject* Outer,
		TArray<FString>& GameDataPath,
		bool NextToken = true
	);

	FString CombineGameDataPath(const TArray<FString>& GameDataPath);
	TSharedPtr<FJsonObject> MergeGameData(const TSharedPtr<FJsonObject>& GameDataDocument, const TSharedPtr<FJsonObject>& PatchDocument);
	TSharedPtr<FJsonValue> MergeDocumentCollection(TSharedRef<FJsonValue> OriginalCollection, TSharedRef<FJsonValue> ModifiedCollection, const FString TypeName, bool PurgeRest);
	TSharedPtr<FJsonValue> MergeDocument(TSharedRef<FJsonValue> OriginalDocument, TSharedRef<FJsonValue> ModifiedDocument, const FString& TypeName);
	typedef TOptional<TFunction<TSharedPtr<FJsonValue>(TSharedRef<FJsonValue>, TSharedRef<FJsonValue>)>> OptionalMergeValueFunc;
	void MergePropertyDocumentValue(TSharedRef<FJsonObject> MergedDocument, TSharedRef<FJsonObject> OriginalDocument, TSharedRef<FJsonObject> ModifiedDocument, const FString PropertyName, OptionalMergeValueFunc MergeFn = OptionalMergeValueFunc());
	void MergePropertyLanguagesValue(TSharedRef<FJsonObject> MergedDocument, TSharedRef<FJsonObject> OriginalDocument, TSharedRef<FJsonObject> ModifiedDocument, const FString PropertyName);
	void MergePropertyValue(TSharedRef<FJsonObject> MergedDocument, TSharedRef<FJsonObject> OriginalDocument, TSharedRef<FJsonObject> ModifiedDocument, const FString PropertyName, OptionalMergeValueFunc MergeFn = OptionalMergeValueFunc());
	TSharedRef<FJsonValue> MergeLocalizedText(TSharedRef<FJsonValue> OriginalLocalizedText, TSharedRef<FJsonValue> ModifiedLocalizedText);
	TSharedRef<TArray<FString>> MergeKeys(const TMap<FString, TSharedPtr<FJsonValue>>& Collection1, const TMap<FString, TSharedPtr<FJsonValue>>& Collection2);
public:
	void ResolveAllReferences();
	void FindAllDocuments();

	class FVisitor
	{
	public:
		virtual ~FVisitor() = default;

		/*
         * Base visit method. Called to dispatch each document.
		 */
		virtual void Visit(UGameDataDocument* Document);

		// visit methods
		virtual void Visit(UTestDataProjectSettings& Document);
		virtual void Visit(UTestEntity& Document);
		virtual void Visit(URecursiveEntity& Document);
		virtual void Visit(UNumberTestEntity& Document);
		virtual void Visit(UUniqueAttributeEntity& Document);
	};

	void ApplyVisitor(FVisitor& Visitor) const;

	class FFindingVisitor : public FVisitor
	{
	public:
		// collected documents
		TArray<UTestDataProjectSettings*> ProjectSettings = TArray<UTestDataProjectSettings*>();
		TArray<UTestEntity*> TestEntity = TArray<UTestEntity*>();
		TArray<URecursiveEntity*> RecursiveEntity = TArray<URecursiveEntity*>();
		TArray<UNumberTestEntity*> NumberTestEntity = TArray<UNumberTestEntity*>();
		TArray<UUniqueAttributeEntity*> UniqueAttributeEntity = TArray<UUniqueAttributeEntity*>();

		// visit methods
		virtual void Visit(UTestDataProjectSettings& Document) override;
		virtual void Visit(UTestEntity& Document) override;
		virtual void Visit(URecursiveEntity& Document) override;
		virtual void Visit(UNumberTestEntity& Document) override;
		virtual void Visit(UUniqueAttributeEntity& Document) override;
	};

private:
	class FDereferencingVisitor : public FVisitor
	{
		// visit methods
		virtual void Visit(UTestDataProjectSettings& Document) override;
		virtual void Visit(UTestEntity& Document) override;
		virtual void Visit(URecursiveEntity& Document) override;
		virtual void Visit(UNumberTestEntity& Document) override;
		virtual void Visit(UUniqueAttributeEntity& Document) override;
	};
};
